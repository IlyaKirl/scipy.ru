<!DOCTYPE html>
<html lang="en">

  <head>
    
    <!-- Meta Tag -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <!-- SEO -->
    <meta name="description" content="учебник scipy, пакет программ для научных вычислений, специальные функции, интегрирование, оптимизация, интерполяция, преобразования Фурье, цифровая обработка сигналов, линейная алгебра, проблема собственных значений разреженных матриц, алгоритмы на разреженных графах, пространственные структуры данных и алгоритмы, статистика, обработка многомерных данных, numpy">
    <meta name="author" content="labintsevai">
    <meta name="url" content="http://www.scipy-tutorial.ru">
    <meta name="copyright" content="labintsevai">
    <meta name="robots" content="index,follow">
	
	
<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(51612041, "init", {
        id:51612041,
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/51612041" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
    
    <title>SciPy Преобразования Фурье</title>
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon/favicon.ico">
    <link rel="apple-touch-icon" sizes="144x144" type="image/x-icon" href="images/favicon/apple-touch-icon.png">
    
    <!-- All CSS Plugins -->
    <link rel="stylesheet" type="text/css" href="css/plugin.css">
    
    <!-- Main CSS Stylesheet -->
    <link rel="stylesheet" type="text/css" href="css/style.css">
    
    <!-- Google Web Fonts  -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins:400,300,500,600,700">
    
    <!-- Syntax Highlighter  -->
    <link rel="stylesheet" type="text/css" href="css/syntax/shCore.css">
    <link rel="stylesheet" type="text/css" href="css/syntax/shThemeDefault.css">

    	<!-- MathJax support-->
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async>
</script>


    
    <!-- HTML5 shiv and Respond.js support IE8 or Older for HTML5 elements and media queries -->
    <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    

  </head>

 <body>

	
     
	 <!-- Preloader Start -->
     <div class="preloader">
	   <div class="rounder"></div>
      </div>
      <!-- Preloader End -->
      
      
    
    
<div id="main">
<div class="container">
<div class="row">
            	
               
                 
 <!-- About Me (Left Sidebar) Start -->
 <div class="col-md-3">
   <div class="about-fixed">

	 <div class="my-pic">
		<img src="images/pic/scipyLogo.png" alt="">
	 </div>
	  
	  
	  
	  <div class="my-detail">
		
		<div class="white-spacing">
			<h1><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/index.html">SciPy.org</a></h1>
			<span>Научные вычисления</span>
		</div> 
	   
	   <ul class="social-icon">
		 <li><a href="https://www.facebook.com/scipyconf" target="_blank" class="facebook"><i class="fa fa-facebook"></i></a></li>
		 <li><a href="https://twitter.com/hashtag/scipy" target="_blank" class="twitter"><i class="fa fa-twitter"></i></a></li>
		<li><a href="https://github.com/scipy" target="_blank" class="github"><i class="fa fa-github"></i></a></li>
		</ul>

	</div>
  </div>
</div>
<!-- About Me (Left Sidebar) End -->

                
                
                
                 
 <!-- Blog Post (Right Sidebar) Start -->
	<div class="col-md-9">
	<div class="col-md-12 page-body">
	<div class="row">
	
	
	<div class="sub-title">
		<h2><a href="index.html">Содержание</h2></a>
	</div>
	
	
	<div class="col-md-12 content-page">
	<div class="col-md-12 blog-post">
		
		
	<!-- Post Headline Start -->
	<div class="post-title">
	<ul class="simple">
	<li><h4>Преобразования Фурье</h4><ul>
	<li><a class="reference internal" href="#id1">Быстрое преобразования Фурье</a>
		<ul class="simple">
		<li>Одномерное дискретное преобразования Фурье </li>
		<li>Двух и n-мерные дискретные преобразования Фурье </li>
		<li>Свертка через БПФ </li>
		</ul>
	</li>
	<li><a class="reference internal" href="#id2">Дискретное косинус преобразование</a>
		<ul class="simple">
		<li>ДКП-1 </li>
		<li>ДКП-2 </li>
		<li>ДКП-3 </li>
		<li>ДКП и обратное ДКП </li>
		</ul>
	</li>
	<li><a class="reference internal" href="#id3">Дискретное синус преобразование</a>
		<ul class="simple">
		<li>ДСП-1 </li>
		<li>ДСП-2 </li>
		<li>ДСП-3 </li>
		<li>ДСП и обратное ДСП </li>
		</ul>	
	</li>
	<li><a class="reference internal" href="#id4">Кэш память и ее очистка</a></li>
	<li><a class="reference internal" href="#id5">Ссылки</a></li>
	</ul>
	</li>
	</ul>
	</div>
	<!-- Post Headline End -->
	
		<p>
		Фурье-анализ - это метод представления сигнала в виде суммы периодических компонентов и обратного восстановления сигнала из этих компонентов. 
		Когда сам сигнала и его Фурье-образ представлены дискретными отсчетами, речь идет о  дискретном преобразовании Фурье (ДПФ, DFT).  
		ДПФ лежит в основе алгоритма  быстрого преобразования Фурье (БПФ, FFT). БПФ было известно еще Гаусу (1805), а в его текущей форме впервые опубликовано Кули и Туки [CT65] . 
		[NR07] рекомендуется в качестве доступного введения в анализ Фурье и его приложения.  
		Также рекомендуется учебник «ЦОС» Опенгейма и Шафера.
		</p>
		<p>
		Заметка 
		Библиотека PyFFTW содержит функции, аналогичные scipy.fftpack, которые работают значительно быстрее, чем вызов через pyfftw.interfaces . 
		Поскольку PyFFTW основан на библиотеке FFTW, лицензированной по GPL, она не может быть включена в Scipy. 
		Для приложений, критических к скорости вычисления БПФ, необходимо рассмотреть PyFFTW в качестве альтернативы scipy.fftpack . 
		</p>
		
	<!-- Section Start -->			 
	<div class="section" id="id1">
	<h3>Быстрое преобразования Фурье (БПФ)</h3>
	
	<div>
	<h4>Одномерное дискретное преобразование Фурье</h4>

		<p>
БПФ \(y [k]\)  длины N  для последовательности входных данных длины - N \(x [n]\) определяется как 
$$y[k]=\sum\limits_{n=0}^{N−1}e^{−2πjkn/N} x[n]$$,
Обратное преобразование определяется следующим образом 
$$x[n]=\frac 1 N  \sum\limits_{k=0}^{N−1}e^{2πjkn/N} y[k] $$
Эти преобразования могут быть вычислены с помощью функций fft и ifft соответственно, как показано в следующем примере. 
		</p>
		
		<!-- Post Coding (SyntaxHighlighter) Start -->
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">
>>>  from scipy.fftpack import fft , ifft
>>>  x = np . array ([ 1.0 , 2.0 , 1.0 , - 1.0 , 1.5 ])
>>>  y = fft ( x )
>>>  y
array([ 4.5       +0.j        ,  2.08155948-1.65109876j,
       -1.83155948+1.60822041j, -1.83155948-1.60822041j,
        2.08155948+1.65109876j])
>>>  yinv = ifft ( y )
>>>  yinv
array([ 1.0+0.j,  2.0+0.j,  1.0+0.j, -1.0+0.j,  1.5+0.j])
		</pre>
		</div>
		<!-- Post Coding (SyntaxHighlighter) End -->
		
		<p>	
Из определения БПФ видно, что 
$$y[0]=\sum\limits_{n=0}^{N−1} x[n] $$
В нашем примере 
		</p>

 >>>  np . sum ( x )
4.5
		<p>
Это соответствует y[0].
		</p>
		<p>		
 Для четных $N$ элементы \(y[1] ... y[N/2−1]\) содержат положительно-частотные члены, а элементы \(y[N/2]...y[N−1]\) содержат отрицательно-частотные члены в порядке убывания частоты.  
 Для нечетных элементов N  \(y[1]...y[(N−1)/2]\) содержат положительно-частотные члены, а элементы \(y[(N+1)/2]...y[N−1]\) содержат отрицательно-частотные члены в порядке убывания частоты. 
		</p>
		<p>		
Если последовательность х вещественная, значения \(y[n]\) для положительных частот являются комплексно сопряженными значениям \(y[n]\) для отрицательных частот (спектр симметричен). 
Как правило, на графиках строится только значения \(y[n]\), соответствующие положительным частотам. 
		</p>
		<p>
В этом примере вычисляется БПФ суммы двух синусоидальных сигналов. 
		</p>
		
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">
>>>  from scipy.fftpack import fft
>>>  # Number of sample points
>>>  N = 600
>>>  # sample spacing
>>>  T = 1.0 / 800.0
>>>  x = np . linspace ( 0.0 , N * T , N )
>>>  y = np . sin ( 50.0 * 2.0 * np . pi * x ) + 0.5 * np . sin ( 80.0 * 2.0 * np . pi * x )
>>>  yf = fft ( y )
>>>  xf = np . linspace ( 0.0 , 1.0 / ( 2.0 * T ), N // 2 )
>>>  import matplotlib.pyplot as plt
>>>  plt . plot ( xf , 2.0 / N * np . abs ( yf [ 0 : N // 2 ]))
>>>  plt . grid ()
>>>  plt . show ()
		</pre>
		</div>
		

		<div class="post-image margin-top-40 margin-bottom-40">
		   <img src="img/fftpack-1.png" alt="">
		</div>
		
		<p>
Идеальный входной сигнал бесконечный во времени, что затрудняет его обработку. 
Для нужд Фурье анализа используется выборка из N значений сигнала. 
Эта выборка может быть получена как умножение бесконечного сигнала на прямоугольную оконную функцию.  
В спектральной области умножение представляет собой свертку спектра сигнала со спектром оконной функции, имеющей вид sin(x)/x . 
Эта свертка является причиной эффекта, называемого растеканием спектра (см. [WPW] ). 
Применение специальных оконных функций помогает уменьшить растекание спектра. 
В приведенном ниже примере используется окно Блэкмана из пакета scipy.signal (нулевой компонент FFT для наглядности был усечен). 
		</p>
		
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">		
 >>>  from scipy.fftpack import fft
>>>  # Number of sample points
>>>  N = 600
>>>  # sample spacing
>>>  T = 1.0 / 800.0
>>>  x = np . linspace ( 0.0 , N * T , N )
>>>  y = np . sin ( 50.0 * 2.0 * np . pi * x ) + 0.5 * np . sin ( 80.0 * 2.0 * np . pi * x )
>>>  yf = fft ( y )
>>>  from scipy.signal import blackman
>>>  w = blackman ( N )
>>>  ywf = fft ( y * w )
>>>  xf = np . linspace ( 0.0 , 1.0 / ( 2.0 * T ), N / 2 )
>>>  import matplotlib.pyplot as plt
>>>  plt . semilogy ( xf [ 1 : N // 2 ], 2.0 / N * np . abs ( yf [ 1 : N // 2 ]), '-b' )
>>>  plt . semilogy ( xf [ 1 : N // 2 ], 2.0 / N * np . abs ( ywf [ 1 : N // 2 ]), '-r' )
>>>  plt . legend ([ 'FFT' , 'FFT w. window' ])
>>>  plt . grid ()
>>>  plt . show ()
		</pre>
		</div>
		
		<div class="post-image margin-top-40 margin-bottom-40">
		   <img src="img/fftpack-2.png" alt="">
		</div>
		
		<p>
Если последовательность х комплексная, спектр уже не будет симметричным. 
		</p>
		<p>
Чтобы упростить работу с функциями FFT, scipy предоставляет следующие две вспомогательные функции fftfreq и fftshift. 

Функция fftfreq возвращает массив со значениями частот, в которых будут вычисляться отсчеты Фурье образа. 
В качестве аргументов передается длина выборки n и интервал между отсчетами d (по умолчанию равен 1). 
		</p>
		
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">		
 >>>  from scipy.fftpack import fftfreq
>>>  freq = fftfreq ( 8 , 0.125 )
>>>  freq
array([ 0., 1., 2., 3., -4., -3., -2., -1.])
		</pre>
		</div>
		
		<p>
Функция fftshift позволяет поменять местами нижнюю и верхнюю половину вектора значений частот. 
Это необходимо для наглядного отображения значений Фурье образа БПФ. 
		</p>
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">
>>>  from scipy.fftpack import fftshift
>>>  x = np . arange ( 8 )
>>>  fftshift ( x )
array([4, 5, 6, 7, 0, 1, 2, 3])
		</pre>
		</div>
		
		<p>
В следующем примере показан БПФ двух комплексных экспонент. Обратите внимание на асимметричный спектр. 
		</p>
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">		
>>>  from scipy.fftpack import fft , fftfreq , fftshift
>>>  # number of signal points
>>>  N = 400
>>>  # sample spacing
>>>  T = 1.0 / 800.0
>>>  x = np . linspace ( 0.0 , N * T , N )
>>>  y = np . exp ( 50.0 * 1. j * 2.0 * np . pi * x ) + 0.5 * np . exp ( - 80.0 * 1. j * 2.0 * np . pi * x )
>>>  yf = fft ( y )
>>>  xf = fftfreq ( N , T )
>>>  xf = fftshift ( xf )
>>>  yplot = fftshift ( yf )
>>>  import matplotlib.pyplot as plt
>>>  plt . plot ( xf , 1.0 / N * np . abs ( yplot ))
>>>  plt . grid ()
>>>  plt . show ()
		</pre>
		</div>
		
		<div class="post-image margin-top-40 margin-bottom-40">
		   <img src="img/fftpack-3.png" alt="">
		</div>
		
		<p>
Функция rfft вычисляет БПФ последовательности действительных чисел и выдает коэффициенты Фурье образа y[n] с отдельными вещественными и мнимыми частями. 
В случае четных N: \([y[0],Re(y[1]),Im(y[1]),...,Re(y[N/2])]\). 
В случае, когда N нечетно \([y[0],Re(y[1]),Im(y[1]),...,Re(y[N/2]),Im(y[N/2])] \). 
		</p>
		<p>		
Соответственно, функция irfft вычисляет обратное ДПФ для массива коэффициентов Фурье образа, расположенных в порядке, указанном выше. 
		</p>
		
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">		
 >>>  from scipy.fftpack import fft , rfft , irfft
>>>  x = np . array ([ 1.0 , 2.0 , 1.0 , - 1.0 , 1.5 , 1.0 ])
>>>  fft ( x )
array([ 5.5 +0.j        ,  2.25-0.4330127j , -2.75-1.29903811j,
        1.5 +0.j        , -2.75+1.29903811j,  2.25+0.4330127j ])
>>>  yr = rfft ( x )
>>>  yr
array([ 5.5       ,  2.25      , -0.4330127 , -2.75      , -1.29903811,
        1.5       ])
>>>  irfft ( yr )
array([ 1. ,  2. ,  1. , -1. ,  1.5,  1. ])
>>>  x = np . array ([ 1.0 , 2.0 , 1.0 , - 1.0 , 1.5 ])
>>>  fft ( x )
array([ 4.5       +0.j        ,  2.08155948-1.65109876j,
       -1.83155948+1.60822041j, -1.83155948-1.60822041j,
        2.08155948+1.65109876j])
>>>  yr = rfft ( x )
>>>  yr
array([ 4.5       ,  2.08155948, -1.65109876, -1.83155948,  1.60822041])
		</pre>
		</div>

	</div>

	<div>
	<h4>Двух и n-мерные дискретные преобразования Фурье</h4>
	
Функции fft2 и ifft2 обеспечивают 2-мерное БПФ и обратное БПФ соответственно. Аналогично, fftn и ifftn обеспечивают n-мерный FFT и IFFT соответственно. 
 В примере ниже показан 2-мерный IFFT и полученные в результате 2-мерные сигналы во временной области. 
 
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">
>>>  from scipy.fftpack import ifftn
>>>  import matplotlib.pyplot as plt
>>>  import matplotlib.cm as cm
>>>  N = 30
>>>  f , (( ax1 , ax2 , ax3 ), ( ax4 , ax5 , ax6 )) = plt . subplots ( 2 , 3 , sharex = 'col' , sharey = 'row' )
>>>  xf = np . zeros (( N , N ))
>>>  xf [ 0 , 5 ] = 1
>>>  xf [ 0 , N - 5 ] = 1
>>>  Z = ifftn ( xf )
>>>  ax1 . imshow ( xf , cmap = cm . Reds )
>>>  ax4 . imshow ( np . real ( Z ), cmap = cm . gray )
>>>  xf = np . zeros (( N , N ))
>>>  xf [ 5 , 0 ] = 1
>>>  xf [ N - 5 , 0 ] = 1
>>>  Z = ifftn ( xf )
>>>  ax2 . imshow ( xf , cmap = cm . Reds )
>>>  ax5 . imshow ( np . real ( Z ), cmap = cm . gray )
>>>  xf = np . zeros (( N , N ))
>>>  xf [ 5 , 10 ] = 1
>>>  xf [ N - 5 , N - 10 ] = 1
>>>  Z = ifftn ( xf )
>>>  ax3 . imshow ( xf , cmap = cm . Reds )
>>>  ax6 . imshow ( np . real ( Z ), cmap = cm . gray )
>>>  plt . show ()
 
	</div>


	<div>
	<h4>Свертка через БПФ</h4>
	
scipy.fftpack.convolve выполняет свертку двух одномерных массивов в частотной области. 

	</div>

	
	
	</div>
	<!-- Section End -->		
	
	<!-- Section Start -->			 
	<div class="section" id="id2">
	<h3>Дискретное косинус преобразование</h3>

		<p>
Дискретным косинус-преобразованием (ДКП, DCT) называется преобразование вида $$A[k]=\sum\limits_{n=0}^{N-1} x[n]\phi^*_k [n] $$ $$ x[n]=\sum\limits_{n=0}^{N-1} A[k] \phi_k [n] $$ в которых базисной последовательностью \(\phi _k \) служат косинусы. Scipy предоставляет ДКП (DCT) с функцией dct и соответствующим IDCT с функцией idct . Всего существует 8 типов DCT [WPC], [Mak], однако в scipy реализованы только первые 3 типа. По умолчанию под DCT обычно подразумевают DCT-типа 2, а IDCT - IDCT 3. Кроме того, коэффициенты DCT могут быть по-разному нормализованы (для большинства типов scipy обеспечивает None и ortho). Два параметра вызовов функции dct / idct позволяют установить тип DCT и нормализовать коэффициенты. 
Для одномерного массива x, dct (x, norm = 'ortho') соответствует функции MATLAB dct (x). 
		</p>
		
<h4>ДКП-1 </h4>
		<p>
Scipy использует следующее определение ненормализованного DCT-1 ( norm='None' ): 
$$y[k]=x_0+(−1)^k x_{N−1} +2 \sum\limits _{n=1}^{N−2} x[n] cos(\frac{\pi n k}{N−1} ) $$ , \( 0 \le k \le N \)
 
В качестве режима нормализации для DCT-I поддерживается только None . Также обратите внимание, что DCT-I поддерживается только для входных векторов размером >  1.
		</p>
		
<h4>ДКП-2</h4>
		<p>
Scipy использует следующее определение ненормализованного DCT-II (norm='None' ): 
$$ y[k]=2\sum\limits_{n=0}^{N−1} x[n] cos(\frac{π(2n+1)k}{2N})$$ \( 0 \le k \le N \)
В случае ортонормализованного DCT ( norm='ortho' ) коэффициенты DCT y[k] умножаются на коэффициент масштабирования f : 
$$f = \begin{cases} \sqrt{1/(4N)}, & \text{if $k = 0$} \\    \sqrt{1/(2N)},
& \text{otherwise} \end{cases} \, . $$.
В этом случае базовые функции ДКП \(ϕ_k[n]=2fcos⁡(π(2n+1)k2N) \) действительно становятся ортонормированными: 
$$ \sum\limits_{n=0}^{N−1} ϕ_k[n] ϕ_l[n]=δ_{lk}$$
		</p>
<h4>ДКП-3 </h4>
		<p>
В Scipy используется следующее ненормализованное DCT-III ( norm='None' ): 
$$ y[k] = x_0 + 2 \sum_{n=1}^{N-1} x[n] \cos\left({\pi n(2k+1) \over 2N}\right)
\qquad 0 \le k < N,$$
или, для norm='ortho' : 
$$ y[k] = {x_0\over\sqrt{N}} + {2\over\sqrt{N}} \sum_{n=1}^{N-1} x[n]
\cos\left({\pi n(2k+1) \over 2N}\right) \qquad 0 \le k < N. $$
		</p>

<h4>ДКП и обратное ДКП </h4>
		<p>
Ненормированный DCT-III является инвертированным (ненормализованным) DCT-II, умноженный на коэффициент 2N . Ортонормированный DCT-III является равным обратному ортонормированному DCT-II. Функция idct обеспечивает правильное сопоставление между типами DCT и IDCT. 
В приведенном ниже примере показано соотношение между DCT и IDCT для разных типов и способов нормализации. 
		</p>
		
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">
>>>  from scipy.fftpack import dct , idct
>>>  x = np . array ([ 1.0 , 2.0 , 1.0 , - 1.0 , 1.5 ])
>>>  dct ( dct ( x , type = 2 , norm = 'ortho' ), type = 3 , norm = 'ortho' )
[1.0, 2.0, 1.0, -1.0, 1.5]
>>>  # scaling factor 2*N = 10
>>>  idct ( dct ( x , type = 2 ), type = 2 )
array([ 10.,  20.,  10., -10.,  15.])
>>>  # no scaling factor
>>>  idct ( dct ( x , type = 2 , norm = 'ortho' ), type = 2 , norm = 'ortho' )
array([ 1. ,  2. ,  1. , -1. ,  1.5])
>>>  # scaling factor 2*N = 10
>>>  idct ( dct ( x , type = 3 ), type = 3 )
array([ 10.,  20.,  10., -10.,  15.])
>>>  # no scaling factor
>>>  idct ( dct ( x , type = 3 , norm = 'ortho' ), type = 3 , norm = 'ortho' )
array([ 1. ,  2. ,  1. , -1. ,  1.5])
>>>  # scaling factor 2*(N-1) = 8
>>>  idct ( dct ( x , type = 1 ), type = 1 )
array([  8.,  16.,   8.,  -8.,  12.])
		</pre>
		</div>

</h4>Пример <h4>
		<p>
ДКП имеет свойство «уплотнения энергии». Это означает, что для многих сигналов только первые несколько DCT-коэффициентов имеют значительную величину. Если отбросить остальные коэффициенты приводит к небольшой ошибке восстановления, которая используется при сжатии с потерями (например, сжатие JPEG). 
В приведенном ниже примере показан сигнал x и две реконструкции ( x20 и x15 ) из коэффициентов DCT сигнала. Сигнал x20 восстанавливается из первых 20 коэффициентов DCT, x15 восстанавливается из первых 15 коэффициентов DCT. Можно видеть, что относительная погрешность использования 20 коэффициентов по-прежнему очень мала (~ 0,1%), но обеспечивает пятикратную степень сжатия. 
		</p>
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">
>>>  from scipy.fftpack import dct , idct
>>>  import matplotlib.pyplot as plt
>>>  N = 100
>>>  t = np . linspace ( 0 , 20 , N )
>>>  x = np . exp ( - t / 3 ) * np . cos ( 2 * t )
>>>  y = dct ( x , norm = 'ortho' )
>>>  window = np . zeros ( N )
>>>  window [: 20 ] = 1
>>>  yr = idct ( y * window , norm = 'ortho' )
>>>  sum ( abs ( x - yr ) ** 2 ) / sum ( abs ( x ) ** 2 )
0.0010901402257
>>>  plt . plot ( t , x , '-bx' )
>>>  plt . plot ( t , yr , 'ro' )
>>>  window = np . zeros ( N )
>>>  window [: 15 ] = 1
>>>  yr = idct ( y * window , norm = 'ortho' )
>>>  sum ( abs ( x - yr ) ** 2 ) / sum ( abs ( x ) ** 2 )
0.0718818065008
>>>  plt . plot ( t , yr , 'g+' )
>>>  plt . legend ([ 'x' , '$x_ {20} $' , '$x_ {15} $' ])
>>>  plt . grid ()
>>>  plt . show ()
		</pre>
		</div>

		
	</div>
	<!-- Section End -->		

	<!-- Section Start -->			 
	<div class="section" id="id3">
	<h3>Дискретное синус преобразование</h3>

		<p>
В Scipy предоставлены дискретные синус-преобразования (ДСП, DST) [Mak]  функцией dst и соответствующим IDST с функцией idst . 
Теоретически существует 8 типов DST для разных комбинаций четных / нечетных граничных условий и граничных с множеств [WPS]. В scipy реализованы только первые 3 типа. 
		</p>
		
<h4>ДСП-1 </h4>
		<p>
DST-I предполагает, что входной вектор нечетен вокруг n = -1 и n = N. В Scipy используется следующее определение ненормализованного DST-I (norm='None' ): 
$$ y[k] = 2\sum_{n=0}^{N-1} x[n]  \sin\left( \pi {(n+1) (k+1)}\over{N+1}
\right), \qquad 0 \le k < N. $$
В качестве режима нормализации для DST-I поддерживается только None. Также обратите внимание, что DST-I поддерживается только для входных векторов размером > 1. Ненормализованный DST-I является его собственным инверсным, с точностью до коэффициента 2 (N + 1) . 
		</p>

<h4>ДСП-2 </h4>
		<p>
DST-II предполагает, что вход нечетен вокруг n = -1/2 и вокруг n = N. В Scipy используется следующее определение ненормализованного DST-II (norm='None' ): 
$$ y[k] = 2 \sum_{n=0}^{N-1} x[n]  \sin\left( {\pi (n+1/2)(k+1)} \over N
\right), \qquad 0 \le k < N. $$
		</p>
		
<h4>ДСП-3</h4>

		<p>
DST-III предполагает, что вход нечетен вокруг n = -1 и даже вокруг n = N-1. В Scipy используется следующее определение ненормализованного DST-III ( norm='None' ): 
$$ y[k] = (-1)^k x[N-1] + 2 \sum_{n=0}^{N-2} x[n] \sin \left( {\pi
(n+1)(k+1/2)} \over N \right), \qquad 0 \le k < N. $$
		</p>

<h4>ДСП и обратное ДСП </h4>

		<p>
В приведенном ниже примере показано соотношение между DST и IDST для разных типов и способов нормализации. 
		</p>
		
		<div class="margin-top-40 margin-bottom-40">  
		<pre class="brush: python">
 >>>  from scipy.fftpack import dst , idst
>>>  x = np . array ([ 1.0 , 2.0 , 1.0 , - 1.0 , 1.5 ])
>>>  # scaling factor 2*N = 10
>>>  idst ( dst ( x , type = 2 ), type = 2 )
array([ 10.,  20.,  10., -10.,  15.])
>>>  # no scaling factor
>>>  idst ( dst ( x , type = 2 , norm = 'ortho' ), type = 2 , norm = 'ortho' )
array([ 1. ,  2. ,  1. , -1. ,  1.5])
>>>  # scaling factor 2*N = 10
>>>  idst ( dst ( x , type = 3 ), type = 3 )
array([ 10.,  20.,  10., -10.,  15.])
>>>  # no scaling factor
>>>  idst ( dst ( x , type = 3 , norm = 'ortho' ), type = 3 , norm = 'ortho' )
array([ 1. ,  2. ,  1. , -1. ,  1.5])
>>>  # scaling factor 2*(N+1) = 8
>>>  idst ( dst ( x , type = 1 ), type = 1 )
array([ 12.,  24.,  12., -12.,  18.])
		</pre>
		</div>

	</div>
	<!-- Section End -->		

	<!-- Section Start -->			 
	<div class="section" id="id4">
	<h3>Кэш память и ее очистка</h3>

		<p>
 Для ускорения повторных преобразований на массивах одинаковой формы и типа dtype scipy.fftpack хранит кеш простой факторизации (разложение на простые числа) длины массива и предварительно вычисленных тригонометрических функций. Эти кеши можно очистить, вызвав соответствующую функцию в scipy.fftpack._fftpack . dst (тип = 1) и idst (тип = 1) совместно используют кеш ( *dst1_cache ). Как и dst (тип = 2), dst (тип = 3), idst (тип = 3) и idst (тип = 3) совместно используют кеш ( *dst2_cache ). 

		</p>
		
	</div>
	<!-- Section End -->		

	<!-- Section Start -->			 
	<div class="section" id="id5">
	<h3>Ссылки</h3>

		<p>
[CT65]	Cooley, James W., and John W. Tukey, 1965, "An algorithm for the machine calculation of complex Fourier series," Math. Comput. 19: 297-301.
		</p>
		<p>
[NR07]	Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, Numerical Recipes: The Art of Scientific Computing, ch. 12-13. Cambridge Univ. Press, Cambridge, UK.
		</p>
		<p>
[Mak]	(1, 2) J. Makhoul, 1980, 'A Fast Cosine Transform in One and Two Dimensions', IEEE Transactions on acoustics, speech and signal processing vol. 28(1), pp. 27-34, :doi: 10.1109/TASSP.1980.1163351
		</p>
		<p>
[WPW]	https://en.wikipedia.org/wiki/Window_function
		</p>
		<p>
[WPC]	https://en.wikipedia.org/wiki/Discrete_cosine_transform
		</p>
		<p>
[WPS]	https://en.wikipedia.org/wiki/Discrete_sine_transform
		</p>

	</div>
	<!-- Section End -->		

<!-- Footer Start -->
<div class="col-md-12 page-body margin-top-50 footer">
  <footer>
  <ul class="menu-link">
	   <li><a href="index.html">Содержание</a></li>
	   <li><a href="about.html">О сайте</a></li>
	</ul>
	
  <p>© Copyright 2016 DevBlog. All rights reserved</p>
  
						  
  <!-- UiPasta Credit Start -->
  <div class="uipasta-credit">Design By <a href="http://www.uipasta.com" target="_blank">UiPasta</a></div>
  <!-- UiPasta Credit End -->
  
   
 </footer>
</div>
 <!-- Footer End -->
			 
  </div>
  </div>
  
  </div>
  </div>
  </div>
  <!-- Blog Post (Right Sidebar) End -->
		
</div>
</div>
</div>




<!-- Endpage Box (Popup When Scroll Down) Start 
<div id="scroll-down-popup" class="endpage-box">
<h4>Read Also</h4>
<a href="#">How to make your company website based on bootstrap framework...</a>
</div>
<!-- Endpage Box (Popup When Scroll Down) End -->




<!-- Back to Top Start -->
<a href="#" class="scroll-to-top"><i class="fa fa-long-arrow-up"></i></a>
<!-- Back to Top End -->


<!-- All Javascript Plugins  -->
<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plugin.js"></script>

<!-- Main Javascript File  -->
<script type="text/javascript" src="js/scripts.js"></script>
    
<!-- Syntax Highlighter Javascript File  -->
<script type="text/javascript" src="js/syntax/shCore.js"></script>
<script type="text/javascript" src="js/syntax/shBrushCss.js"></script>
<script type="text/javascript" src="js/syntax/shBrushJScript.js"></script>
<script type="text/javascript" src="js/syntax/shBrushPerl.js"></script>
<script type="text/javascript" src="js/syntax/shBrushPhp.js"></script>
<script type="text/javascript" src="js/syntax/shBrushPlain.js"></script>
<script type="text/javascript" src="js/syntax/shBrushPython.js"></script>
<script type="text/javascript" src="js/syntax/shBrushRuby.js"></script>
<script type="text/javascript" src="js/syntax/shBrushSql.js"></script>
<script type="text/javascript" src="js/syntax/shBrushVb.js"></script>
<script type="text/javascript" src="js/syntax/shBrushXml.js"></script>

<!-- Syntax Highlighter Call Function -->
<script type="text/javascript">
SyntaxHighlighter.config.clipboardSwf = 'js/syntax/clipboard.swf';
SyntaxHighlighter.all();
</script>


</body>
</html>
