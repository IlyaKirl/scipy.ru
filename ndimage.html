<!DOCTYPE html>
<html lang="en">

  <head>
    
    <!-- Meta Tag -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <!-- SEO -->
    <meta name="description" content="учебник scipy, пакет программ для научных вычислений, специальные функции, интегрирование, оптимизация, интерполяция, преобразования Фурье, цифровая обработка сигналов, линейная алгебра, проблема собственных значений разреженных матриц, алгоритмы на разреженных графах, пространственные структуры данных и алгоритмы, статистика, обработка многомерных данных, numpy">
    <meta name="author" content="labintsevai">
    <meta name="url" content="http://www.scipy-tutorial.ru">
    <meta name="copyright" content="labintsevai">
    <meta name="robots" content="index,follow">
	
	 
<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(51612041, "init", {
        id:51612041,
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/51612041" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
    
    <title>SciPy Обработка многомерных данных</title>
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon/favicon.ico">
    <link rel="apple-touch-icon" sizes="144x144" type="image/x-icon" href="images/favicon/apple-touch-icon.png">
    
    <!-- All CSS Plugins -->
    <link rel="stylesheet" type="text/css" href="css/plugin.css">
    
    <!-- Main CSS Stylesheet -->
    <link rel="stylesheet" type="text/css" href="css/style.css">
    
    <!-- Google Web Fonts  -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins:400,300,500,600,700">
    
    <!-- Syntax Highlighter  -->
    <link rel="stylesheet" type="text/css" href="css/syntax/shCore.css">
    <link rel="stylesheet" type="text/css" href="css/syntax/shThemeDefault.css">
    
        	<!-- MathJax support-->
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

    <!-- HTML5 shiv and Respond.js support IE8 or Older for HTML5 elements and media queries -->
    <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    

  </head>

 <body>

	<!-- Preloader Start -->
     <div class="preloader">
	   <div class="rounder"></div>
      </div>
      <!-- Preloader End -->
      
      
    
    
<div id="main">
<div class="container">
<div class="row">

<!-- About Me (Left Sidebar) Start -->
<div class="col-md-3">
<div class="about-fixed">

<div class="my-pic">
<img src="images/pic/scipyLogo.png" alt="">
</div>



<div class="my-detail">

<div class="white-spacing">
	<h1><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/index.html">SciPy.org</a></h1>
	<span>Научные вычисления</span>
</div> 

<ul class="social-icon">
 <li><a href="https://www.facebook.com/scipyconf" target="_blank" class="facebook"><i class="fa fa-facebook"></i></a></li>
 <li><a href="https://twitter.com/hashtag/scipy" target="_blank" class="twitter"><i class="fa fa-twitter"></i></a></li>
<li><a href="https://github.com/scipy" target="_blank" class="github"><i class="fa fa-github"></i></a></li>
</ul>

</div>
</div>
</div>
<!-- About Me (Left Sidebar) End -->

<!-- Blog Post (Right Sidebar) Start -->
<div class="col-md-9">
<div class="col-md-12 page-body">
<div class="row">
	
<div class="sub-title">
	<h2><a href="index.html">Содержание</h2></a>
 </div>

<div class="col-md-12 content-page">
	<div class="col-md-12 blog-post">

	<!-- Post Headline Start -->
	<div class="post-title">
	<ul class="simple">
	<h4>Обработка многомерных данных (scipy.ndimage)</h4>
		<li><a class="reference internal" href="#id1">Введение </a></li>
		<li><a class="reference internal" href="#id2">Общие свойства функций </a></li>
		<li><a class="reference internal" href="#id3">Фильтрация </a>
			<ul><li>Корреляция и свертка </li>
			<li>Сглаживающие фильтры </li>
			<li>Статистические фильтры </li>
			<li>Производные </li>
			<li>Обобщенная фильтрация </li>
			<li>Фильтрация Фурье </li>
			</ul>
		</li>
		<li><a class="reference internal" href="#id4">Интерполяция </a>
			<ul><li>Сплайн предварительная фильтрация </li>
			<li>Функции интерполяции </li>
			</ul>
		</li>
		<li><a class="reference internal" href="#id5">Морфология </a>
			<ul><li>Бинарная морфология </li>
			<li>Серая морфология </li>
			</ul>
		</li>
		<li><a class="reference internal" href="#id6">Преобразование расстояний </a></li>
		<li><a class="reference internal" href="#id7">Сегментация и нумерация </a></li>
		<li><a class="reference internal" href="#id8">Измерение объектов </a></li>
		<li><a class="reference internal" href="#id9">Расширение scipy.ndimage на языке С </a>
			<ul><li>Numba </li>
			<li>Cython </li>
			<li>cffi </li>
			<li>ctypes </li>
			</ul>
		</li>
		<li><a class="reference internal" href="#id10">Ссылки </a></li>
	</ul>
	</div>
	   <!-- Post Headline End -->
	   
<h2>Многомерная обработка изображений (scipy.ndimage)</h2>

<div class="section" id="id1">
<h3>Вступление</h3>
	<p>
Обработка и анализ изображений обычно сводятся к операциям над двумерными массивами значений. Однако существует ряд приложений, в которых необходимо анализировать данные большей размерности. Хорошими примерами таких приложений являются визуализация медицинских и биологических данных. numpy очень хорошо подходит для обработки многомерных данных. Пакет программ scipy.ndimage содержит ряд общих функций обработки и анализа данных, которые предназначены для работы с массивами произвольной размерности. Пакеты в настоящее время включают функции для линейной и нелинейной фильтрации, бинарной морфологии, интерполяции B-сплайнами и измерения объектов.
	</p>
</div>

<div class="section" id="id2">
<h3>Общие свойства функций</h3>
	<p>
Все функции имеют общие свойства. Примечательно, что все функции позволяют специфицировать выходной массив с выходным аргументом. С помощью этого аргумента вы можете указать массив, который будет изменен на месте с результатом с помощью операции. В этом случае результат не возвращается. Обычно использование выходного аргумента более эффективно, поскольку для хранения результата используется существующий массив.
<br>
Тип возвращаемых массивов зависит от типа операции, но в большинстве случаев он равен типу ввода. Если, однако, используется выходной аргумент, тип результата будет равен типу указанного выходного аргумента. Если выходной аргумент не задан, все же можно указать, каков будет результат вывода. Это делается путем простого назначения целевого объекта типа numpy выходному аргументу. Например:
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
from scipy.ndimage import correlate
correlate(np.arange(10), [1, 2.5])
array([ 0,  2,  6,  9, 13, 16, 20, 23, 27, 30])
correlate(np.arange(10), [1, 2.5], output=np.float64)
array([  0. ,   2.5,   6. ,   9.5,  13. ,  16.5,  20. ,  23.5,  27. ,  30.5])
	</pre>
	</div>

</div>

<div class="section" id="id3">
<h3>Фильтрация</h3>
	<p>
Все функции, описанные в этом разделе, выполняют некоторый тип пространственной фильтрации входного массива: элементы в выходных данных являются некоторой функцией значений в окрестности соответствующего входного элемента. Мы называем эту окрестность элементов ядром фильтра, которое часто имеет прямоугольную форму, но также может иметь произвольную площадь. Многие из функций, описанных ниже, позволяют вам определять зону обслуживания ядра, передавая маску через параметр footprint . Например, крестообразное ядро ​​может быть определено следующим образом:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
footprint = np . array ([[ 0 , 1 , 0 ], [ 1 , 1 , 1 ], [ 0 , 1 , 0 ]])
footprint
array([[0, 1, 0],
       [1, 1, 1],
       [0, 1, 0]])
	</pre>
	</div>

	<p>
Обычно начало ядра находится в центре, который вычисляется путем деления размеров формы ядра на два. Например, происхождение одномерного ядра длиной три находится во втором элементе. Возьмем, к примеру, корреляцию одномерного массива с фильтром длины 3, состоящим из единиц:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
from scipy.ndimage import correlate1d
a = [ 0 , 0 , 0 , 1 , 0 , 0 , 0 ]
correlate1d ( a , [ 1 , 1 , 1 ])
array([0, 0, 1, 1, 1, 0, 0])
	</pre>
	</div>

	<p>
Иногда удобно выбрать другое происхождение для ядра. По этой причине большинство функций поддерживают параметр origin, который дает начало фильтра относительно его центра. Например:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
a = [ 0 , 0 , 0 , 1 , 0 , 0 , 0 ]
correlate1d ( a , [ 1 , 1 , 1 ], origin = - 1 )
array([0, 1, 1, 1, 0, 0, 0])
	</pre>
	</div>

	<p>
Эффект - это смещение результата влево. Эта функция не понадобится очень часто, но она может быть полезна, особенно для фильтров, которые имеют четный размер. Хорошим примером является расчет обратной и прямой разницы:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
a = [ 0 , 0 , 1 , 1 , 1 , 0 , 0 ]
correlate1d ( a , [ - 1 , 1 ])               # backward difference
array([ 0,  0,  1,  0,  0, -1,  0])
correlate1d ( a , [ - 1 , 1 ], origin = - 1 )  # forward difference
array([ 0,  1,  0,  0, -1,  0,  0])
	</pre>
	</div>

	<p>
Мы могли бы также рассчитать разницу вперед следующим образом:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 correlate1d ( a , [ 0 , - 1 , 1 ])
array([ 0,  1,  0,  0, -1,  0,  0])
	</pre>
	</div>

	<p>
Однако использование параметра origin вместо более крупного ядра более эффективно. Для многомерных ядер начало координат может быть числом, и в этом случае начало координат предполагается равным по всем осям, или последовательностью, дающей начало координат по каждой оси.

Поскольку выходные элементы являются функцией элементов в окрестности входных элементов, с границами массива необходимо обращаться соответствующим образом, предоставляя значения за пределами границ. Это сделано, предполагая, что массивы расширены за их границы согласно определенным граничным условиям. В функциях, описанных ниже, граничные условия можно выбирать с помощью параметра mode, который должен быть строкой с названием граничного условия. В настоящее время поддерживаются следующие граничные условия:

«Ближайший»	Используйте значение на границе	[1 2 3] -> [1 1 2 3 3]
"заворачивать"	Периодически копировать массив	[1 2 3] -> [3 1 2 3 1]
«Отражать»	Отражать массив на границе	[1 2 3] -> [1 1 2 3 3]
«Константа»	Используйте постоянное значение, по умолчанию 0,0	[1 2 3] -> [0 1 2 3 0]
Режим «константа» является особенным, так как для него требуется дополнительный параметр для указания постоянного значения, которое следует использовать.

Заметка 
Самый простой способ реализовать такие граничные условия - скопировать данные в больший массив и расширить данные на границах в соответствии с граничными условиями. Для больших массивов и больших ядер фильтров это будет очень занимать память, и поэтому функции, описанные ниже, используют другой подход, который не требует выделения больших временных буферов.
	</p>
	
<h4>Корреляция и свертка </h4>
	<p>
Функция correlate1d вычисляет одномерную корреляцию по заданной оси. Линии массива вдоль заданной оси коррелируют с заданными весами . Параметр весов должен быть одномерной последовательностью чисел.

Функция correlate реализует многомерную корреляцию входного массива с данным ядром.

Функция convolve1d вычисляет одномерную свертку вдоль заданной оси. Линии массива вдоль заданной оси свернуты с заданными весами . Параметр весов должен быть одномерной последовательностью чисел.

Заметка 
Свертка по сути является корреляцией после зеркального отображения ядра. В результате исходный параметр ведет себя иначе, чем в случае корреляции: результат смещается в противоположных направлениях.

Функция convolve реализует многомерную свертку входного массива с данным ядром.

Заметка 
Свертка по сути является корреляцией после зеркального отображения ядра. В результате исходный параметр ведет себя иначе, чем в случае корреляции: результаты смещаются в противоположном направлении.
	</p>

<h4>Сглаживающие фильтры </h4>
	<p>
Функция gaussian_filter1d реализует одномерный фильтр Гаусса. Стандартное отклонение фильтра Гаусса передается через параметр sigma . Установка порядка = 0 соответствует свертке с гауссовым ядром. Порядок 1, 2 или 3 соответствует свертке с первой, второй или третьей производной гауссиана. Производные высшего порядка не реализованы.

Функция gaussian_filter реализует многомерный фильтр Гаусса. Стандартные отклонения фильтра Гаусса вдоль каждой оси пропускаются через сигма параметра в виде последовательности или чисел. Если сигма не последовательность, а одно число, стандартное отклонение фильтра одинаково по всем направлениям. Порядок фильтра может быть указан отдельно для каждой оси. Порядок 0 соответствует свертке с гауссовым ядром. Порядок 1, 2 или 3 соответствует свертке с первой, второй или третьей производной гауссиана. Производные высшего порядка не реализованы. Параметр порядка должен быть числом, чтобы указать одинаковый порядок для всех осей, или последовательностью чисел, чтобы указать различный порядок для каждой оси.

Заметка 
Многомерный фильтр реализован в виде последовательности одномерных гауссовых фильтров. Промежуточные массивы хранятся в том же типе данных, что и выходные данные. Поэтому для типов вывода с более низкой точностью результаты могут быть неточными, поскольку промежуточные результаты могут храниться с недостаточной точностью. Этого можно избежать, указав более точный тип вывода.

uniform_filter1d вычисляет одномерный равномерный фильтр заданного размера вдоль заданной оси.

uniform_filter реализует многомерный равномерный фильтр. Размеры унифицированного фильтра задаются для каждой оси в виде последовательности целых чисел параметром size . Если размер не последовательность, а одно число, размеры по всей оси предполагаются равными.

Заметка 
Многомерный фильтр реализован в виде последовательности одномерных равномерных фильтров. Промежуточные массивы хранятся в том же типе данных, что и выходные данные. Поэтому для типов вывода с более низкой точностью результаты могут быть неточными, поскольку промежуточные результаты могут храниться с недостаточной точностью. Этого можно избежать, указав более точный тип вывода.
	</p>
	
<h4>Фильтры заданного порядка</h4>
	<p>
minimum_filter1d вычисляет одномерный минимальный фильтр заданного размера вдоль заданной оси.
Функция maximum_filter1d вычисляет одномерный максимальный фильтр заданного размера вдоль заданной оси.
minimum_filter вычисляет многомерный фильтр минимума. Должны быть указаны размеры прямоугольного ядра или площадь ядра. Параметр size , если он указан, должен быть последовательностью размеров или одним числом, и в этом случае размер фильтра предполагается равным вдоль каждой оси. След , если он указан, должен быть массивом, который определяет форму ядра его ненулевыми элементами.
Функция maximum_filter вычисляет многомерный максимальный фильтр. Должны быть указаны размеры прямоугольного ядра или площадь ядра. Параметр size , если он указан, должен быть последовательностью размеров или одним числом, и в этом случае размер фильтра предполагается равным вдоль каждой оси. След , если он указан, должен быть массивом, который определяет форму ядра его ненулевыми элементами.
Функция rank_filter вычисляет многомерный фильтр ранга. Ранг может быть меньше нуля, т. Е. Ранг = -1 указывает на самый большой элемент. Должны быть указаны размеры прямоугольного ядра или площадь ядра. Параметр size , если он указан, должен быть последовательностью размеров или одним числом, и в этом случае размер фильтра предполагается равным вдоль каждой оси. След , если он указан, должен быть массивом, который определяет форму ядра его ненулевыми элементами.
Функция percentile_filter вычисляет многомерный процентильный фильтр. Процентиль может быть меньше нуля, т. Е. Процентиль = -20 равен процентилю = 80. Должны быть указаны размеры прямоугольного ядра или площадь ядра. Параметр size , если он указан, должен быть последовательностью размеров или одним числом, и в этом случае размер фильтра предполагается равным вдоль каждой оси. След , если он указан, должен быть массивом, который определяет форму ядра его ненулевыми элементами.
Функция median_filter вычисляет многомерный медианный фильтр. Должны быть указаны размеры прямоугольного ядра или площадь ядра. Параметр size , если он указан, должен быть последовательностью размеров или одним числом, и в этом случае размер фильтра предполагается равным вдоль каждой оси. След, если он указан, должен быть массивом, который определяет форму ядра его ненулевыми элементами.
	</p>
	
<h4>Производные </h4>
	<p>
Производные фильтры могут быть построены несколькими способами. Функция gaussian_filter1d описанная в фильтрах сглаживания, может использоваться для вычисления производных по заданной оси с использованием параметра порядка . Другими производными фильтрами являются фильтры Prewitt и Sobel:

Функция prewitt вычисляет производную по заданной оси.
Функция sobel вычисляет производную по заданной оси.
Фильтр Лапласа рассчитывается по сумме вторых производных по всем осям. Таким образом, разные фильтры Лапласа могут быть построены с использованием разных функций второй производной. Поэтому мы предоставляем общую функцию, которая принимает аргумент функции для вычисления второй производной по заданному направлению.

Функция generic_laplace вычисляет фильтр generic_laplace используя функцию, переданную derivative2 для вычисления вторых производных. Функция derivative2 должна иметь следующую подпись
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 derivative2 ( input , axis , output , mode , cval , * extra_arguments , ** extra_keywords )
	</pre>
	</div>

Следует рассчитать вторую производную вдоль размерной оси . Если output не None он должен использовать это для вывода и вернуть None, в противном случае он должен вернуть результат. mode , cval имеют обычное значение.

Аргументы extra_arguments и extra_keywords могут использоваться для передачи кортежа дополнительных аргументов и словаря именованных аргументов, которые передаются derivative2 при каждом вызове.

Например
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 def d2 ( input , axis , output , mode , cval ):
...     return correlate1d ( input , [ 1 , - 2 , 1 ], axis , output , mode , cval , 0 )
...
a = np . zeros (( 5 , 5 ))
a [ 2 , 2 ] = 1
from scipy.ndimage import generic_laplace
generic_laplace ( a , d2 )
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1., -4.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
	</pre>
	</div>

	<p>
Чтобы продемонстрировать использование аргумента extra_arguments, мы могли бы сделать
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 def d2 ( input , axis , output , mode , cval , weights ):
...     return correlate1d ( input , weights , axis , output , mode , cval , 0 ,)
...
a = np . zeros (( 5 , 5 ))
a [ 2 , 2 ] = 1
generic_laplace ( a , d2 , extra_arguments = ([ 1 , - 2 , 1 ],))
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1., -4.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
	</pre>
	</div>

	<p>
или же
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 generic_laplace ( a , d2 , extra_keywords = { 'weights' : [ 1 , - 2 , 1 ]})
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1., -4.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
	</pre>
	</div>

	<p>	   
Следующие две функции реализованы с использованием generic_laplace , предоставляя соответствующие функции для второй производной функции:

Функция Лапласа вычисляет Лапласа с использованием дискретного дифференцирования для второй производной (т.е. свертка с [1, -2, 1] ).
Функция gaussian_laplace вычисляет фильтр Лапласа, используя gaussian_filter для вычисления вторых производных. Стандартные отклонения фильтра Гаусса вдоль каждой оси пропускаются через сигма параметра в виде последовательности или чисел. Если сигма не последовательность, а одно число, стандартное отклонение фильтра одинаково по всем направлениям.
Величина градиента определяется как квадратный корень из суммы квадратов градиентов во всех направлениях. Подобно общей функции Лапласа, есть функция generic_gradient_magnitude которая вычисляет величину градиента массива.

Функция generic_gradient_magnitude вычисляет величину градиента, используя функцию, переданную через derivative для вычисления первых производных. Производная функции должна иметь следующую подпись

 derivative ( input , axis , output , mode , cval , * extra_arguments , ** extra_keywords )
Следует рассчитать производную по оси измерения. Если output не None, он должен использовать это для вывода и вернуть None, в противном случае он должен вернуть результат. mode , cval имеют обычное значение.

Аргументы extra_arguments и extra_keywords могут использоваться для передачи кортежа дополнительных аргументов и словаря именованных аргументов, которые передаются производным при каждом вызове.

Например, функция sobel соответствует требуемой подписи
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 a = np . zeros (( 5 , 5 ))
a [ 2 , 2 ] = 1
from scipy.ndimage import sobel , generic_gradient_magnitude
generic_gradient_magnitude ( a , sobel )
array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],
       [ 0.        ,  2.        ,  0.        ,  2.        ,  0.        ],
       [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
	</pre>
	</div>
	<p>
Смотрите документацию к generic_laplace для примеров использования аргументов extra_arguments и extra_keywords .

Функции sobel и prewitt соответствуют требуемой сигнатуре и поэтому могут напрямую использоваться с generic_gradient_magnitude .

Функция gaussian_gradient_magnitude вычисляет величину градиента, используя gaussian_filter для вычисления первых производных. Стандартные отклонения фильтра Гаусса вдоль каждой оси пропускаются через сигма параметра в виде последовательности или чисел. Если сигма не последовательность, а одно число, стандартное отклонение фильтра одинаково по всем направлениям.
	</p>
	
Общие функции фильтра 
	<p>
Для реализации функций фильтра можно использовать универсальные функции, которые принимают вызываемый объект, который реализует операцию фильтрации. Итерация по входным и выходным массивам обрабатывается этими общими функциями, а также такими деталями, как реализация граничных условий. Должен быть предоставлен только вызываемый объект, реализующий функцию обратного вызова, которая выполняет фактическую работу фильтрации. Функция обратного вызова также может быть написана на C и передана с использованием PyCapsule (для получения дополнительной информации см. Расширение scipy.ndimage в C ).

Функция generic_filter1d реализует универсальную функцию одномерного фильтра, где фактическая операция фильтрации должна быть предоставлена ​​как функция python (или другой вызываемый объект). Функция generic_filter1d выполняет generic_filter1d по строкам массива и вызывает function в каждой строке. Аргументы, которые передаются в function являются одномерными массивами типа np.float64 . Первый содержит значения текущей строки. Он расширяется в начале и в конце, в соответствии с аргументами filter_size и origin . Второй массив должен быть модифицирован на месте, чтобы обеспечить выходные значения строки. Например, рассмотрим корреляцию по одному измерению:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
a = np . arange ( 12 ) . reshape ( 3 , 4 )
correlate1d ( a , [ 1 , 2 , 3 ])
array([[ 3,  8, 14, 17],
       [27, 32, 38, 41],
       [51, 56, 62, 65]])
	</pre>
	</div>

	<p>
Эта же операция может быть реализована с использованием generic_filter1d следующим образом:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 def fnc ( iline , oline ):
...     oline [ ... ] = iline [: - 2 ] + 2 * iline [ 1 : - 1 ] + 3 * iline [ 2 :]
...
from scipy.ndimage import generic_filter1d
generic_filter1d ( a , fnc , 3 )
array([[ 3,  8, 14, 17],
       [27, 32, 38, 41],
       [51, 56, 62, 65]])
	</pre>
	</div>

	<p>
Здесь источник ядра (по умолчанию) предполагался в середине фильтра длины 3. Следовательно, каждая строка ввода была расширена на одно значение в начале и в конце, прежде чем была вызвана функция.

При желании могут быть определены дополнительные аргументы и переданы в функцию фильтра. Аргументы extra_arguments и extra_keywords могут использоваться для передачи кортежа дополнительных аргументов и / или словаря именованных аргументов, которые передаются производным при каждом вызове. Например, мы можем передать параметры нашего фильтра в качестве аргумента
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 def fnc ( iline , oline , a , b ):
...     oline [ ... ] = iline [: - 2 ] + a * iline [ 1 : - 1 ] + b * iline [ 2 :]
...
generic_filter1d ( a , fnc , 3 , extra_arguments = ( 2 , 3 ))
array([[ 3,  8, 14, 17],
       [27, 32, 38, 41],
       [51, 56, 62, 65]])
	</pre>
	</div>

	<p>
или же
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 generic_filter1d ( a , fnc , 3 , extra_keywords = { 'a' : 2 , 'b' : 3 })
array([[ 3,  8, 14, 17],
       [27, 32, 38, 41],
       [51, 56, 62, 65]])
	</pre>
	</div>

	<p>
Функция generic_filter реализует универсальную функцию фильтра, где фактическая операция фильтрации должна быть предоставлена ​​как функция python (или другой вызываемый объект). Функция generic_filter выполняет итерации по массиву и вызывает function для каждого элемента. Аргумент function - это одномерный массив типа np.float64 , который содержит значения вокруг текущего элемента, которые находятся в зоне действия фильтра. Функция должна возвращать одно значение, которое может быть преобразовано в число с двойной точностью. Например, рассмотрим соотношение:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 a = np . arange ( 12 ) . reshape ( 3 , 4 )
correlate ( a , [[ 1 , 0 ], [ 0 , 3 ]])
array([[ 0,  3,  7, 11],
       [12, 15, 19, 23],
       [28, 31, 35, 39]])
	</pre>
	</div>

	<p>
Эта же операция может быть реализована с использованием generic_filter следующим образом:
	</p>
	
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 def fnc ( buffer ):
...     return ( buffer * np . array ([ 1 , 3 ])) . sum ()
...
from scipy.ndimage import generic_filter
generic_filter ( a , fnc , footprint = [[ 1 , 0 ], [ 0 , 1 ]])
array([[ 0,  3,  7, 11],
       [12, 15, 19, 23],
       [28, 31, 35, 39]])
	</pre>
	</div>

	<p>
Здесь был указан след ядра, который содержит только два элемента. Поэтому функция фильтра получает буфер длиной два, который умножается на правильные веса и результат суммируется.

При вызове generic_filter должны быть generic_filter размеры прямоугольного ядра или размер ядра. Параметр size , если он указан, должен быть последовательностью размеров или одним числом, и в этом случае размер фильтра предполагается равным вдоль каждой оси. След , если он указан, должен быть массивом, который определяет форму ядра его ненулевыми элементами.

При желании могут быть определены дополнительные аргументы и переданы в функцию фильтра. Аргументы extra_arguments и extra_keywords могут использоваться для передачи кортежа дополнительных аргументов и / или словаря именованных аргументов, которые передаются производным при каждом вызове. Например, мы можем передать параметры нашего фильтра в качестве аргумента
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 def fnc ( buffer , weights ):
...     weights = np . asarray ( weights )
...     return ( buffer * weights ) . sum ()
...
generic_filter ( a , fnc , footprint = [[ 1 , 0 ], [ 0 , 1 ]], extra_arguments = ([ 1 , 3 ],))
array([[ 0,  3,  7, 11],
       [12, 15, 19, 23],
       [28, 31, 35, 39]])
	</pre>
	</div>

	<p>	   
или же
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 generic_filter ( a , fnc , footprint = [[ 1 , 0 ], [ 0 , 1 ]], extra_keywords = { 'weights' : [ 1 , 3 ]})
array([[ 0,  3,  7, 11],
       [12, 15, 19, 23],
       [28, 31, 35, 39]])
	</pre>
	</div>

	<p>	   
Эти функции выполняют итерации по линиям или элементам, начиная с последней оси, т.е. последний индекс изменяется быстрее всего. Этот порядок итерации гарантирован для случая, когда важно адаптировать фильтр в зависимости от пространственного расположения. Вот пример использования класса, который реализует фильтр и отслеживает текущие координаты во время итерации. Он выполняет ту же операцию фильтра, что и описанную выше для generic_filter , но дополнительно печатает текущие координаты:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 a = np . arange ( 12 ) . reshape ( 3 , 4 )
>>>
class fnc_class :
...     def __init__ ( self , shape ):
...         # store the shape:
...         self . shape = shape
...         # initialize the coordinates:
...         self . coordinates = [ 0 ] * len ( shape )
...
...     def filter ( self , buffer ):
...         result = ( buffer * np . array ([ 1 , 3 ])) . sum ()
...         print ( self . coordinates )
...         # calculate the next coordinates:
...         axes = list ( range ( len ( self . shape )))
...         axes . reverse ()
...         for jj in axes :
...             if self . coordinates [ jj ] < self . shape [ jj ] - 1 :
...                 self . coordinates [ jj ] += 1
...                 break
...             else :
...                 self . coordinates [ jj ] = 0
...         return result
...
fnc = fnc_class ( shape = ( 3 , 4 ))
generic_filter ( a , fnc . filter , footprint = [[ 1 , 0 ], [ 0 , 1 ]])
[0, 0]
[0, 1]
[0, 2]
[0, 3]
[1, 0]
[1, 1]
[1, 2]
[1, 3]
[2, 0]
[2, 1]
[2, 2]
[2, 3]
array([[ 0,  3,  7, 11],
       [12, 15, 19, 23],
       [28, 31, 35, 39]])
	</pre>
	</div>

	<p>
Для функции generic_filter1d работает тот же подход, за исключением того, что эта функция не выполняет итерации по фильтруемой оси. Пример для generic_filter1d становится следующим:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 a = np . arange ( 12 ) . reshape ( 3 , 4 )
>>>
class fnc1d_class :
...     def __init__ ( self , shape , axis = - 1 ):
...         # store the filter axis:
...         self . axis = axis
...         # store the shape:
...         self . shape = shape
...         # initialize the coordinates:
...         self . coordinates = [ 0 ] * len ( shape )
...
...     def filter ( self , iline , oline ):
...         oline [ ... ] = iline [: - 2 ] + 2 * iline [ 1 : - 1 ] + 3 * iline [ 2 :]
...         print ( self . coordinates )
...         # calculate the next coordinates:
...         axes = list ( range ( len ( self . shape )))
...         # skip the filter axis:
...         del axes [ self . axis ]
...         axes . reverse ()
...         for jj in axes :
...             if self . coordinates [ jj ] < self . shape [ jj ] - 1 :
...                 self . coordinates [ jj ] += 1
...                 break
...             else :
...                 self . coordinates [ jj ] = 0
...
fnc = fnc1d_class ( shape = ( 3 , 4 ))
generic_filter1d ( a , fnc . filter , 3 )
[0, 0]
[1, 0]
[2, 0]
array([[ 3,  8, 14, 17],
       [27, 32, 38, 41],
       [51, 56, 62, 65]])
	</pre>
	</div>

Фильтры доменов Фурье 
	<p>
Функции, описанные в этом разделе, выполняют операции фильтрации в области Фурье. Таким образом, входной массив такой функции должен быть совместим с функцией обратного преобразования Фурье, такой как функции из модуля numpy.fft . Поэтому нам приходится иметь дело с массивами, которые могут быть результатом действительного или комплексного преобразования Фурье. В случае реального преобразования Фурье сохраняется только половина симметричного комплексного преобразования. Кроме того, необходимо знать, какая длина оси была преобразована с помощью реального БПФ. Функции, описанные здесь, предоставляют параметр n, который в случае реального преобразования должен быть равен длине оси реального преобразования до преобразования. Если этот параметр меньше нуля, предполагается, что входной массив был результатом комплексного преобразования Фурье. Ось параметров может использоваться для указания, по какой оси было выполнено реальное преобразование.

Функция fourier_shift умножает входной массив на многомерное преобразование Фурье операции сдвига для данного сдвига. Параметр сдвига представляет собой последовательность сдвигов для каждого измерения или одно значение для всех измерений.
Функция fourier_gaussian умножает входной массив на многомерное преобразование Фурье гауссовского фильтра с заданной сигма стандартных отклонений. Параметр sigma представляет собой последовательность значений для каждого измерения или одно значение для всех измерений.
Функция fourier_uniform умножает входной массив на многомерное преобразование Фурье однородного фильтра с заданным размером . Параметр размера представляет собой последовательность значений для каждого измерения или одно значение для всех измерений.
Функция fourier_ellipsoid умножает входной массив на многомерное преобразование Фурье фильтра эллиптической формы с заданным размером . Параметр размера представляет собой последовательность значений для каждого измерения или одно значение для всех измерений. Эта функция реализована только для измерений 1, 2 и 3.
	</p>
	
</div>

<div class="section" id="id4">
<h3>Функции интерполяции</h3>

В этом разделе описываются различные функции интерполяции, основанные на теории B-сплайнов. Хорошее введение в B-сплайны можно найти в [1].
Предварительная фильтрация сплайнов

Интерполяция с использованием сплайнов порядка больше 1 требует предварительной фильтрации. Интерполяционные функции, описанные в разделе: ref: `ndimage-interpolation` применяют предварительную фильтрацию, вызывая: func:` spline_filter`, но их можно дать указание не делать этого, установив ключевое слово prefilter равным False. Это полезно, если в одном массиве выполняется более одной операции интерполяции. В этом случае более эффективно выполнять предварительную фильтрацию только один раз и использовать предварительно фильтрованный массив в качестве входа функций интерполяции. Следующие две функции реализуют предварительную фильтрацию:

    Функция: func: `spline_filter1d` вычисляет одномерный сплайн-фильтр вдоль данной оси. Может быть предоставлен выходной массив. Порядок сплайна должен быть больше 1 и меньше 6.

    Функция func: `spline_filter` вычисляет многомерный сплайн-фильтр.

    Заметка

    Многомерный фильтр реализуется как последовательность одномерных сплайн-фильтров. Промежуточные массивы хранятся в том же типе данных, что и выходной. Поэтому, если запрашивается выход с ограниченной точностью, результаты могут быть неточными, поскольку промежуточные результаты могут храниться с недостаточной точностью. Этого можно предотвратить, указав тип вывода высокой точности.
	</p>
	
Функции интерполяции
	<p>
Следующие функции используют сплайн-интерполяцию для осуществления некоторого типа геометрического преобразования входного массива. Для этого требуется сопоставление выходных координат с входными координатами, и, следовательно, возникает возможность ввода входных значений за пределы границ. Эта проблема решается так же, как описано в: ref: `ndimage-filter-functions` для многомерных фильтрующих функций. Поэтому эти функции поддерживают параметр режима, который определяет, как обрабатываются границы, и параметр cval, который дает постоянное значение в случае использования режима «константа».

    Функция func: `geometric_transform` применяет произвольное геометрическое преобразование к входу. Данная функция отображения вызывается в каждой точке вывода, чтобы найти соответствующие координаты на входе. mapping должен быть вызываемым объектом, который принимает кортеж длины, равный рангу выходного массива, и возвращает соответствующие входные координаты как кортеж длины, равный рангу входного массива. Могут быть предоставлены форма вывода и тип вывода. Если они не заданы, они равны форме ввода и типу.

    Например:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
    >>> a = np.arange (12) .resape (4,3) .astype (np.float64)
    >>> def shift_func (output_coordinates):
    ... return (output_coordinates [0] - 0.5, output_coordinates [1] - 0.5)
    ...
    >>> from scipy.ndimage import geometric_transform
    >>> geometric_transform (a, shift_func)
    array ([[0., 0., 0.],
           [0., 1.3625, 2.7375],
           [0., 4.8125, 6.1875],
           [0., 8.2625, 9.6375]])
	</pre>
	</div>

	<p>
    Необязательно дополнительные аргументы могут быть определены и переданы функции фильтра. Аргументы extra_arguments и extra_keywords могут использоваться для передачи кортежа дополнительных аргументов и / или словаря именованных аргументов, которые передаются производным при каждом вызове. Например, мы можем передать сдвиги в нашем примере как аргументы
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
    >>> def shift_func (output_coordinates, s0, s1):
    ... return (output_coordinates [0] - s0, output_coordinates [1] - s1)
    ...
    >>> geometric_transform (a, shift_func, extra_arguments = (0.5, 0.5))
    array ([[0., 0., 0.],
           [0., 1.3625, 2.7375],
           [0., 4.8125, 6.1875],
           [0., 8.2625, 9.6375]])
	</pre>
	</div>

	<p>
    или же
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
    >>> geometric_transform (a, shift_func, extra_keywords = {'s0': 0.5, 's1': 0.5})
    array ([[0., 0., 0.],
           [0., 1.3625, 2.7375],
           [0., 4.8125, 6.1875],
           [0., 8.2625, 9.6375]])
	</pre>
	</div>

	<p>
    Заметка

    Функция отображения также может быть записана в C и передана с использованием scipy.LowLevelCallable. См.: Ref: `ndimage-ccallbacks` для получения дополнительной информации.

    Функция: func: `map_coordinates` применяет произвольное преобразование координат с использованием заданного массива координат. Форма вывода выводится из формы массива координат, отбрасывая первую ось. The parameter coordinates is used to find for each point in the output the corresponding coordinates in the input. The values of coordinates along the first axis are the coordinates in the input array at which the output value is found. (See also the numarray coordinates function.) Since the coordinates may be non- integer coordinates, the value of the input at these coordinates is determined by spline interpolation of the requested order.

    Here is an example that interpolates a 2D array at (0.5, 0.5) and (1, 2):
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
    >>> a = np.arange(12).reshape(4,3).astype(np.float64)
    >>> a
    array([[  0.,   1.,   2.],
           [  3.,   4.,   5.],
           [  6.,   7.,   8.],
           [  9.,  10.,  11.]])
    >>> from scipy.ndimage import map_coordinates
    >>> map_coordinates(a, [[0.5, 2], [0.5, 1]])
    array([ 1.3625,  7.])
	</pre>
	</div>

	<p>
    The :func:`affine_transform` function applies an affine transformation to the input array. The given transformation matrix and offset are used to find for each point in the output the corresponding coordinates in the input. The value of the input at the calculated coordinates is determined by spline interpolation of the requested order. The transformation matrix must be two-dimensional or can also be given as a one-dimensional sequence or array. In the latter case, it is assumed that the matrix is diagonal. A more efficient interpolation algorithm is then applied that exploits the separability of the problem. The output shape and output type can optionally be provided. If not given they are equal to the input shape and type.

    The :func:`shift` function returns a shifted version of the input, using spline interpolation of the requested order.

    The :func:`zoom` function returns a rescaled version of the input, using spline interpolation of the requested order.

    The :func:`rotate` function returns the input array rotated in the plane defined by the two axes given by the parameter axes, using spline interpolation of the requested order. The angle must be given in degrees. If reshape is true, then the size of the output array is adapted to contain the rotated input.
	</p>
	
</div>

<div class="section" id="id5">
<h3>Морфология </h3>
Бинарная морфология 
Функции generate_binary_structure генерируют двоичный элемент структурирования для использования в операциях двоичной морфологии. Должен быть предоставлен ранг структуры. Размер возвращаемой структуры равен трем в каждом направлении. Значение каждого элемента равно единице, если квадрат евклидова расстояния от элемента до центра меньше или равен связности . Например, двумерные 4-связные и 8-связные структуры генерируются следующим образом:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 from scipy.ndimage import generate_binary_structure
generate_binary_structure ( 2 , 1 )
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
generate_binary_structure ( 2 , 2 )
array([[ True,  True,  True],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
	</pre>
	</div>

	<p>
Большинство двоичных морфологических функций можно выразить в терминах основных эрозий и дилатации операций.

Функция binary_erosion реализует бинарную эрозию массивов произвольного ранга с данным структурирующим элементом. Параметр origin определяет размещение структурирующего элемента, как описано в разделе « Функции фильтра» . Если элемент структурирования не предоставляется, элемент с связностью, равным единице, генерируется с использованием generate_binary_structure . Параметр border_value дает значение массива вне границ. Эрозия повторяется итерациями раз. Если итераций меньше единицы, эрозия повторяется до тех пор, пока результат не изменится. Если задан массив масок, на каждой итерации изменяются только те элементы с истинным значением в соответствующем элементе маски.
Функция binary_dilation реализует двоичную дилатацию массивов произвольного ранга с данным структурирующим элементом. Параметр origin определяет размещение структурирующего элемента, как описано в разделе « Функции фильтра» . Если элемент структурирования не предоставляется, элемент с связностью, равным единице, генерируется с использованием generate_binary_structure . Параметр border_value дает значение массива вне границ. Дилатация повторяется итерациями . Если итерации меньше единицы, дилатация повторяется до тех пор, пока результат больше не изменится. Если задан массив масок, на каждой итерации изменяются только те элементы с истинным значением в соответствующем элементе маски.
Ниже приведен пример использования binary_dilation для поиска всех элементов, которые касаются границы, путем многократного расширения пустого массива с границы с использованием массива данных в качестве маски:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 struct = np . array ([[ 0 , 1 , 0 ], [ 1 , 1 , 1 ], [ 0 , 1 , 0 ]])
a = np . array ([[ 1 , 0 , 0 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 0 ], [ 0 , 0 , 0 , 0 , 0 ]])
a
array([[1, 0, 0, 0, 0],
       [1, 1, 0, 1, 0],
       [0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0]])
from scipy.ndimage import binary_dilation
binary_dilation ( np . zeros ( a . shape ), struct , - 1 , a , border_value = 1 )
array([[ True, False, False, False, False],
       [ True,  True, False, False, False],
       [False, False, False, False, False],
       [False, False, False, False, False]], dtype=bool)
	</pre>
	</div>

	<p>
У binary_erosion и binary_dilation есть параметр итераций, который позволяет повторять несколько раз размывание или расширение. Повторение эрозии или дилатации с заданной структурой n раз эквивалентно эрозии или дилатации со структурой, которая n-1 раз расширена сама по себе. Предоставляется функция, позволяющая вычислять структуру, которая несколько раз расширялась:

Функция iterate_structure возвращает структуру путем расширения итерации входной структуры - 1 раз с самим собой.

Например:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 struct = generate_binary_structure ( 2 , 1 )
struct
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
from scipy.ndimage import iterate_structure
iterate_structure ( struct , 2 )
array([[False, False,  True, False, False],
       [False,  True,  True,  True, False],
       [ True,  True,  True,  True,  True],
       [False,  True,  True,  True, False],
       [False, False,  True, False, False]], dtype=bool)
	</pre>
	</div>

	<p>
If the origin of the original structure is equal to 0, then it is
also equal to 0 for the iterated structure. If not, the origin
must also be adapted if the equivalent of the *iterations*
erosions or dilations must be achieved with the iterated
structure. The adapted origin is simply obtained by multiplying
with the number of iterations. For convenience the
:func:`iterate_structure` also returns the adapted origin if the
*origin* parameter is not ``None``:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> iterate_structure(struct, 2, -1)
   (array([[False, False,  True, False, False],
           [False,  True,  True,  True, False],
           [ True,  True,  True,  True,  True],
           [False,  True,  True,  True, False],
           [False, False,  True, False, False]], dtype=bool), [-2, -2])
	</pre>
	</div>

	<p>
Другие морфологические операции могут быть определены с точки зрения эрозии и дилатации. Следующие функции обеспечивают некоторые из этих операций для удобства:

Функция binary_opening реализует двоичное открытие массивов произвольного ранга с данным структурирующим элементом. Двоичное открытие эквивалентно бинарной эрозии, за которой следует двоичная дилатация с тем же структурным элементом. Параметр origin определяет размещение структурирующего элемента, как описано в разделе « Функции фильтра» . Если элемент структурирования не предоставляется, элемент с связностью, равным единице, генерируется с использованием generate_binary_structure . Параметр итераций дает количество эрозий, которые выполняются с одинаковым количеством разведений.
Функция binary_closing реализует двоичное закрытие массивов произвольного ранга с данным структурирующим элементом.Двоичное закрытие эквивалентно двоичному расширению с последующей двоичной эрозией с тем же структурирующим элементом. Параметр origin контролирует размещение структурирующего элемента, как описано в функциях Filter . Если структурирующий элемент не предоставлен, элемент с связностью, равной единице, генерируется с помощью generate_binary_structure. Параметр итераций дает количество выполненных дилатаций, за которыми следует такое же количество эрозий.
binary_fill_holesФункция используется , чтобы закрыть отверстия в объектах на бинарном изображении, где структура определяет связность отверстий. Параметр origin контролирует размещение структурирующего элемента, как описано в функциях Filter . Если структурирующий элемент не предоставлен, элемент с связностью, равной единице, генерируется с помощью generate_binary_structure.
binary_hit_or_missФункция реализует бинарный хит-или-мисс преобразования массивов произвольного ранга с данными структурных элементов. Преобразование попадания или пропуска рассчитывается путем размытия входных данных с первой структурой, размытия логического не входного сигнала со второй структурой, за которым следует логическое и из этих двух размывающих элементов. Параметры источника управляют размещением элементов структурирования, как описано в функциях фильтра . Если origin2 равно None, оно устанавливается равным параметру origin1 . Если первый структурирующий элемент не предоставлен, генерируется структурирующий элемент с связностью, равной единице, с использованием generate_binary_structureif struct2не предусмотрено, оно устанавливается равным логическому не из structure1 .
	</p>

Морфология серой шкалы
	<p>
Операции морфологии градаций серого представляют собой эквиваленты операций морфологии двоичных кодов, которые работают с массивами с произвольными значениями. Ниже мы опишем серые эквиваленты эрозии, расширения, открытия и закрытия. Эти операции реализованы аналогично фильтрам, описанным в функциях фильтра , и мы обращаемся к этому разделу за описанием ядер и посадочных мест фильтра, а также обработкой границ массива. Операции морфологии градаций серого необязательно принимают структурный параметр, который дает значения элемента структурирования. Если этот параметр не задан, предполагается, что структурирующий элемент является плоским со значением, равным нулю. Форма конструкции может быть опционально определена посадочной площадкойпараметр. Если этот параметр не задан, структура считается прямоугольной с размерами, равными размерам массива структуры , или параметром размера, если структура не указана. Параметр size используется только в том случае, если не указаны и структура, и размер , и в этом случае структурирующий элемент считается прямоугольным и плоским с размерами, заданными размером . Параметр size , если он указан, должен быть последовательностью размеров или одним числом, и в этом случае размер фильтра предполагается равным вдоль каждой оси. след Параметр, если указан, должен быть массивом, который определяет форму ядра его ненулевыми элементами.

Аналогично бинарной эрозии и дилатации существуют операции для эрозии и дилатации серого:

grey_erosionФункция вычисляет многомерную по серой шкале эрозии.
grey_dilationФункция вычисляет многомерное полутоновое дилатацию.
Операции открытия и закрытия серой шкалы могут быть определены аналогично их двоичным аналогам:

grey_openingФункция реализует полутоновое открытие массивов произвольного ранга. Отверстие серой шкалы эквивалентно эрозии серой шкалы с последующим расширением серой шкалы.
grey_closingФункция реализует полутоновое закрытие массивов произвольного ранга. Открытие серой шкалы эквивалентно расширению серой шкалы с последующей эрозией серой шкалы.
morphological_gradientФункция реализует полутоновое морфологический градиент массивов произвольного ранга. Морфологический градиент серой шкалы равен разнице расширения серой шкалы и эрозии серой шкалы.
morphological_laplaceФункция реализует полутоновый морфологический Лаплас массивов произвольного ранга. Морфологическая шкала градаций серого равна сумме расширения серой шкалы и эрозии серой шкалы минус вдвое больше.
white_tophatФункция реализует белый шляпообразный фильтр массивов произвольного ранга. Белый цилиндр равен разнице входных данных и полутонового отверстия.
Эта black_tophatфункция реализует черный массив фильтров произвольного ранга. Черный цилиндр равен разнице между серой шкалой и входом.
	</p>
	
</div>

<div class="section" id="id6">
<h3>Преобразование расстояний </h3>
	<p>
Преобразования расстояния используются для расчета минимального расстояния от каждого элемента объекта до фона. Следующие функции реализуют преобразование расстояния для трех различных метрик расстояния: евклидово, городское квартал и расстояние шахматной доски.

Функция distance_transform_cdtиспользует алгоритм типа фаски для вычисления преобразования расстояния ввода, заменяя каждый элемент объекта (определяемый значениями больше нуля) кратчайшим расстоянием до фона (все не-объектные элементы). Структура определяет тип снятия фаски. Если структура равна 'cityblock', структура генерируется generate_binary_structureс использованием квадрата расстояния, равного 1. Если структура равна 'chessboard', структура генерируется generate_binary_structureс использованием квадрата расстояния, равного рангу массива. Эти варианты соответствуют общим интерпретациям ситиблоков и метрик расстояния шахматной доски в двух измерениях.

В дополнение к преобразованию расстояний можно рассчитать преобразование объектов. В этом случае индекс ближайшего элемента фона возвращается вдоль первой оси результата. В return_distances и return_indices флаги могут быть использованы для указания , если расстояние преобразования, функция преобразования, или оба должны быть возвращены.

Эти расстояния и индексы аргументы могут быть использованы для дополнительных выходных массивов , которые должны быть правильного размера и типа (как np.int32). Основы алгоритма, использованного для реализации этой функции, описаны в [2] .

Функция distance_transform_edtвычисляет точное евклидово преобразование расстояния ввода, заменяя каждый элемент объекта (определенный значениями больше нуля) кратчайшим евклидовым расстоянием до фона (все не-объектные элементы).

В дополнение к преобразованию расстояний можно рассчитать преобразование объектов. В этом случае индекс ближайшего элемента фона возвращается вдоль первой оси результата. В return_distances и return_indices флаги могут быть использованы для указания , если расстояние преобразования, функция преобразования, или оба должны быть возвращены.

При желании выборка по каждой оси может быть задана параметром выборки, который должен быть последовательностью длины, равной входному рангу, или одним числом, в котором выборка предполагается равной по всем осям.

Эти расстояния и индексы аргументов могут быть использованы , чтобы дать дополнительные выходные массивов , которые должны быть правильного размера и типа ( np.float64а np.int32) .The алгоритм , используемый для реализации этой функции описан в [3] .

Функция distance_transform_bfиспользует алгоритм грубой силы для вычисления преобразования расстояния ввода, заменяя каждый элемент объекта (определенный значениями больше нуля) кратчайшим расстоянием до фона (все элементы, не являющиеся объектами). Метрика должна быть одной из «евклидовых», «городских блоков» или «шахматной доски».

В дополнение к преобразованию расстояний можно рассчитать преобразование объектов. В этом случае индекс ближайшего элемента фона возвращается вдоль первой оси результата. В return_distances и return_indices флаги могут быть использованы для указания , если расстояние преобразования, функция преобразования, или оба должны быть возвращены.

При желании выборка по каждой оси может быть задана параметром выборки, который должен быть последовательностью длины, равной входному рангу, или одним числом, в котором выборка предполагается равной по всем осям. Этот параметр используется только в случае евклидова преобразования расстояния.

Эти расстояния и индексы аргументов могут быть использованы для дополнительных выходных массивов , которые должны быть правильного размера и типа ( np.float64а np.int32).

Заметка 
Эта функция использует алгоритм медленной грубой силы, ее distance_transform_cdtможно использовать для более эффективного расчета преобразований расстояний между городскими блоками и шахматными досками. Эта функция distance_transform_edtможет использоваться для более эффективного расчета точного евклидова преобразования расстояния.
	</p>
</div>

<div class="section" id="id7">
<h3>Сегментация и маркировка </h3>
	<p>
Сегментация - это процесс отделения интересующих объектов от фона. Наиболее простой подход - это, вероятно, определение порога интенсивности, что легко сделать с помощью numpyфункций:
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 a = np . array ([[ 1 , 2 , 2 , 1 , 1 , 0 ],
...               [ 0 , 2 , 3 , 1 , 2 , 0 ],
...               [ 1 , 1 , 1 , 3 , 3 , 2 ],
...               [ 1 , 1 , 1 , 1 , 2 , 1 ]])
np . where ( a > 1 , 1 , 0 )
array([[0, 1, 1, 0, 0, 0],
       [0, 1, 1, 0, 1, 0],
       [0, 0, 0, 1, 1, 1],
       [0, 0, 0, 0, 1, 0]])
	</pre>
	</div>

	<p>
Результатом является двоичное изображение, в котором отдельные объекты все еще должны быть идентифицированы и помечены. Функция labelгенерирует массив, в котором каждому объекту присваивается уникальный номер:

labelФункция генерирует массив , в котором объекты во входных данных помечены с целочисленным индексом. Он возвращает кортеж, состоящий из массива меток объектов и количества найденных объектов, если только не указан выходной параметр, и в этом случае возвращается только количество объектов. Связность объектов определяется структурирующим элементом. Например, в двух измерениях использование четырехсвязного структурирующего элемента дает:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 a = np . array ([[ 0 , 1 , 1 , 0 , 0 , 0 ],[ 0 , 1 , 1 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 1 , 1 , 1 ],[ 0 , 0 , 0 , 0 , 1 , 0 ]])
s = [[ 0 , 1 , 0 ], [ 1 , 1 , 1 ], [ 0 , 1 , 0 ]]
from scipy.ndimage import label
label ( a , s )
(array([[0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 2, 0],
        [0, 0, 0, 2, 2, 2],
        [0, 0, 0, 0, 2, 0]]), 2)
	</pre>
	</div>

	<p>
Эти два объекта не связаны, потому что мы не можем разместить структурирующий элемент так, чтобы он перекрывался с обоими объектами. Однако 8-связный структурирующий элемент приводит только к одному объекту:
	</p>
		
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 a = np . array ([[ 0 , 1 , 1 , 0 , 0 , 0 ],[ 0 , 1 , 1 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 1 , 1 , 1 ],[ 0 , 0 , 0 , 0 , 1 , 0 ]])
s = [[ 1 , 1 , 1 ], [ 1 , 1 , 1 ], [ 1 , 1 , 1 ]]
label ( a , s )[ 0 ]
array([[0, 1, 1, 0, 0, 0],
       [0, 1, 1, 0, 1, 0],
       [0, 0, 0, 1, 1, 1],
       [0, 0, 0, 0, 1, 0]])
	</pre>
	</div>

	<p>
Если структурирующий элемент не предоставлен, он генерируется путем вызова generate_binary_structure(см. Двоичная морфология ) с использованием связности одного (которое в 2D является 4-связной структурой первого примера). Входные данные могут быть любого типа, любое значение, не равное нулю, считается частью объекта. Это полезно, если вам нужно «перемаркировать» массив индексов объектов, например, после удаления нежелательных объектов. Просто примените функцию метки снова к массиву индекса. Например:
	</p>

	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 l , n = label ([ 1 , 0 , 1 , 0 , 1 ])
l
array([1, 0, 2, 0, 3])
l = np . where ( l != 2 , l , 0 )
l
array([1, 0, 0, 0, 3])
label ( l )[ 0 ]
array([1, 0, 0, 0, 2])
	</pre>
	</div>

	<p>
Заметка 
Используемый структурирующий элемент labelсчитается симметричным.

Существует большое количество других подходов для сегментации, например, из оценки границ объектов, которые могут быть получены, например, производными фильтрами. Одним из таких подходов является сегментация водораздела. Функция watershed_iftгенерирует массив, в котором каждому объекту присваивается уникальная метка, из массива, который локализует границы объекта, сгенерированный, например, фильтром величины градиента. Он использует массив, содержащий начальные маркеры для объектов:

watershed_iftФункция применяется водораздел от алгоритма маркеров, с использованием итеративного Forest Transform, как описано в [4] .

Входными данными этой функции являются массив, к которому применяется преобразование, и массив маркеров, которые обозначают объекты уникальной меткой, где любое ненулевое значение является маркером. Например:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 input = np . array ([[ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                   [ 0 , 1 , 1 , 1 , 1 , 1 , 0 ],
...                   [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ],
...                   [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ],
...                   [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ],
...                   [ 0 , 1 , 1 , 1 , 1 , 1 , 0 ],
...                   [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ]], np . uint8 )
markers = np . array ([[ 1 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 2 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ]], np . int8 )
from scipy.ndimage import watershed_ift
watershed_ift ( input , markers )
array([[1, 1, 1, 1, 1, 1, 1],
       [1, 1, 2, 2, 2, 1, 1],
       [1, 2, 2, 2, 2, 2, 1],
       [1, 2, 2, 2, 2, 2, 1],
       [1, 2, 2, 2, 2, 2, 1],
       [1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 1, 1]], dtype=int8)
	</pre>
	</div>

	<p>
Здесь два маркера были использованы для обозначения объекта ( маркер = 2) и фона ( маркер = 1). Порядок их обработки произвольный: перемещение маркера для фона в правый нижний угол массива дает другой результат:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 markers = np . array ([[ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 2 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ]], np . int8 )
watershed_ift ( input , markers )
array([[1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1],
       [1, 1, 2, 2, 2, 1, 1],
       [1, 1, 2, 2, 2, 1, 1],
       [1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1]], dtype=int8)
	</pre>
	</div>

	<p>
В результате объект ( marker = 2) меньше, поскольку второй маркер был обработан ранее. Это может быть нежелательным эффектом, если первый маркер должен был обозначать фоновый объект. Следовательно, watershed_iftмаркеры с отрицательным значением явно обрабатываются как фоновые маркеры и обрабатывают их после обычных маркеров. Например, замена первого маркера отрицательным маркером дает результат, аналогичный первому примеру:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 markers = np . array ([[ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 2 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ],
...                     [ 0 , 0 , 0 , 0 , 0 , 0 , - 1 ]], np . int8 )
watershed_ift ( input , markers )
array([[-1, -1, -1, -1, -1, -1, -1],
       [-1, -1,  2,  2,  2, -1, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1, -1,  2,  2,  2, -1, -1],
       [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)
		</pre>
	</div>

	<p>
Связность объектов определяется структурирующим элементом. Если структурирующий элемент не предоставлен, он генерируется путем вызова generate_binary_structure(см. Двоичная морфология ) с использованием связности одного (который в 2D является 4-связной структурой). Например, использование 8-связной структуры в последнем примере приводит к другому объект:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 watershed_ift ( input , markers ,
...               structure = [[ 1 , 1 , 1 ], [ 1 , 1 , 1 ], [ 1 , 1 , 1 ]])
array([[-1, -1, -1, -1, -1, -1, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1,  2,  2,  2,  2,  2, -1],
       [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)
	</pre>
	</div>

	<p>
Заметка 
Реализация watershed_iftограничивает типы данных ввода np.uint8и np.uint16.
	</p>
</div>

<div class="section" id="id8">
<h3>Измерения объекта</h3>
	<p>
Учитывая массив помеченных объектов, свойства отдельных объектов могут быть измерены. find_objectsФункция может быть использована для создания списка срезов , что для каждого объекта, дают наименьший суб-массив , который полностью содержит объект:

find_objectsФункция находит все объекты в меченого массив и возвращает список ломтиков , которые соответствуют наименьшим регионам в массиве , который содержит объект.

Например:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
a = np . array ([[ 0 , 1 , 1 , 0 , 0 , 0 ],[ 0 , 1 , 1 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 1 , 1 , 1 ],[ 0 , 0 , 0 , 0 , 1 , 0 ]])
l , n = label ( a )
from scipy.ndimage import find_objects
f = find_objects ( l )
a [ f [ 0 ]]
array([[1, 1],
       [1, 1]])
a [ f [ 1 ]]
array([[0, 1, 0],
       [1, 1, 1],
       [0, 1, 0]])
		</pre>
	</div>

	<p>
Функция find_objectsвозвращает срезы для всех объектов, если параметр max_label не больше нуля, и в этом случае возвращаются только первые объекты max_label . Если в массиве меток отсутствует индекс , Noneвместо среза возвращается. Например:
	</p>
	
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 from scipy.ndimage import find_objects
find_objects ([ 1 , 0 , 3 , 4 ], max_label = 3 )
[(slice(0, 1, None),), None, (slice(2, 3, None),)]
	</pre>
	</div>

	<p>
Список срезов, сгенерированных с помощью find_objects, полезен для поиска положения и размеров объектов в массиве, но также может использоваться для выполнения измерений на отдельных объектах. Скажем, мы хотим найти сумму интенсивностей объекта на изображении:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 image = np . arange ( 4 * 6 ) . reshape ( 4 , 6 )
mask = np . array ([[ 0 , 1 , 1 , 0 , 0 , 0 ],[ 0 , 1 , 1 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 1 , 1 , 1 ],[ 0 , 0 , 0 , 0 , 1 , 0 ]])
labels = label ( mask )[ 0 ]
slices = find_objects ( labels )
	</pre>
	</div>

	<p>
Затем мы можем вычислить сумму элементов во втором объекте:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 np . where ( labels [ slices [ 1 ]] == 2 , image [ slices [ 1 ]], 0 ) . sum ()
80
	</pre>
	</div>

	<p>
Это, однако, не особенно эффективно, а также может быть более сложным для других типов измерений. Поэтому определены несколько функций измерения, которые принимают массив меток объекта и индекс измеряемого объекта. Например, вычисление суммы интенсивностей может быть сделано:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 from scipy.ndimage import sum as ndi_sum
ndi_sum ( image , labels , 2 )
80
	</pre>
	</div>

	<p>
Для больших массивов и небольших объектов более эффективно вызывать функции измерения после нарезки массива:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 ndi_sum ( image [ slices [ 1 ]], labels [ slices [ 1 ]], 2 )
80
	</pre>
	</div>

	<p>
В качестве альтернативы, мы можем выполнить измерения для нескольких меток с помощью одного вызова функции, возвращая список результатов. Например, чтобы измерить сумму значений фона и второго объекта в нашем примере, мы даем список меток:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 ndi_sum ( image , labels , [ 0 , 2 ])
array([178.0, 80.0])
	</pre>
	</div>

	<p>
Все функции измерения, описанные ниже, поддерживают параметр индекса, чтобы указать, какой объект (ы) должен быть измерен. Значение индекса по умолчанию - Нет. Это указывает на то, что все элементы, метка которых больше нуля, должны рассматриваться как один объект и измеряться. Таким образом, в этом случае массив меток обрабатывается как маска, определяемая элементами, которые больше нуля. Если индекс представляет собой число или последовательность чисел, он дает метки измеряемых объектов. Если index является последовательностью, возвращается список результатов. Функции, которые возвращают более одного результата, возвращают свой результат в виде кортежа, если индекс представляет собой одно число, или в виде кортежа списков, еслиИндекс представляет собой последовательность.

sumФункция вычисляет сумму элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
meanФункция вычисляет среднее значение элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
varianceФункция вычисляет дисперсию элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
standard_deviationФункция вычисляет стандартное отклонение элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
minimumФункция вычисляет минимум элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
maximumФункция вычисляет максимум элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
minimum_positionФункция вычисляет положение минимума элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
maximum_positionФункция вычисляет положение максимума элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
extremaФункция вычисляет минимум, максимум, и их позиции, из элементов объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете. Результатом является кортеж, дающий минимум, максимум, позицию минимума и позицию максимума. Результат совпадает с кортежем, сформированным по результатам функций минимум , максимум , минимум_позиция и максимум_позиция которые описаны выше.
center_of_massФункция вычисляет центр масс объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете.
histogramФункция вычисляет гистограмму объекта с меткой (ами) , задаваемый индексом , используя метки массив для объекта этикетки. Если индекс равен None, все элементы с ненулевым значением метки обрабатываются как один объект. Если метка есть None, все элементы ввода используются в расчете. Гистограммы определяются их минимумом ( min ), максимумом ( max ) и количеством бинов ( bins ). Они возвращаются как одномерные массивы типа np.int32.
	</p>
	
</div>

<div class="section" id="id9">
<h3>Расширение scipy.ndimage на языке С</h3>
	<p>
Несколько функций scipy.ndimageпринимают аргумент обратного вызова. Это может быть либо функция Python, либо scipy.LowLevelCallableсодержащая указатель на функцию C. Использование функции C, как правило, будет более эффективным, поскольку позволяет избежать накладных расходов при вызове функции Python во многих элементах массива. Чтобы использовать функцию C, вы должны написать расширение C, которое содержит функцию обратного вызова и функцию Python, которая возвращает scipy.LowLevelCallableуказатель на обратный вызов.

Примером функции, которая поддерживает обратные вызовы, является функция geometric_transform, которая принимает функцию обратного вызова, которая определяет отображение из всех выходных координат в соответствующие координаты во входном массиве. Рассмотрим следующий пример Python, который используется geometric_transformдля реализации функции shift.
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 from scipy import ndimage

def transform ( output_coordinates , shift ):
    input_coordinates = output_coordinates [ 0 ] - shift , output_coordinates [ 1 ] - shift
    return input_coordinates

im = np . arange ( 12 ) . reshape ( 4 , 3 ) . astype ( np . float64 )
shift = 0.5
print ( ndimage . geometric_transform ( im , transform , extra_arguments = ( shift ,)))
	</pre>
	</div>

	<p>
Мы также можем реализовать функцию обратного вызова с помощью следующего кода C.
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: plain">	
/* example.c */

#include <Python.h>
#include <numpy/npy_common.h>

static int
_transform(npy_intp *output_coordinates, double *input_coordinates,
           int output_rank, int input_rank, void *user_data)
{
    npy_intp i;
    double shift = *(double *)user_data;

    for (i = 0; i < input_rank; i++) {
        input_coordinates[i] = output_coordinates[i] - shift;
    }
    return 1;
}

static char *transform_signature = "int (npy_intp *, double *, int, int, void *)";

static PyObject *
py_get_transform(PyObject *obj, PyObject *args)
{
    if (!PyArg_ParseTuple(args, "")) return NULL;
    return PyCapsule_New(_transform, transform_signature, NULL);
}

static PyMethodDef ExampleMethods[] = {
    {"get_transform", (PyCFunction)py_get_transform, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL}
};

/* Initialize the module */
#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef example = {
    PyModuleDef_HEAD_INIT,
    "example",
    NULL,
    -1,
    ExampleMethods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC
PyInit_example(void)
{
    return PyModule_Create(&example);
}
#else
PyMODINIT_FUNC
initexample(void)
{
    Py_InitModule("example", ExampleMethods);
}
#endif
	</pre>
	</div>

	<p>
Более подробную информацию о написании модулей расширения Python можно найти здесь . Если код C находится в файле example.c, его можно скомпилировать с помощью следующего setup.py:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 from distutils.core import setup , Extension
import numpy

shift = Extension ( 'example' ,
                  [ 'example.c' ],
                  include_dirs = [ numpy . get_include ()]
)

setup ( name = 'example' ,
      ext_modules = [ shift ]
)
	</pre>
	</div>

	<p>
и теперь запускаю скрипт
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 import ctypes
import numpy as np
from scipy import ndimage , LowLevelCallable

from example import get_transform

shift = 0.5

user_data = ctypes . c_double ( shift )
ptr = ctypes . cast ( ctypes . pointer ( user_data ), ctypes . c_void_p )
callback = LowLevelCallable ( transform (), ptr )
im = np . arange ( 12 ) . reshape ( 4 , 3 ) . astype ( np . float64 )
print ( ndimage . geometric_transform ( im , callback ))
	</pre>
	</div>

	<p>
выдает тот же результат, что и оригинальный скрипт на python.

В версии C _transformесть функция обратного вызова и параметры, output_coordinatesи они input_coordinatesиграют ту же роль, что и в версии Python, output_rankа также input_rankпредоставляют эквиваленты len(output_coordinates)и len(input_coordinates). Переменная shiftпередается user_dataвместо extra_arguments. Наконец, функция обратного вызова C возвращает целочисленный статус, который равен одному при успешном завершении и равен нулю в противном случае.

Функция py_transformоборачивает функцию обратного вызова в PyCapsule. Основными этапами являются:

Инициализировать PyCapsule. Первый аргумент - это указатель на функцию обратного вызова.

Второй аргумент - это сигнатура функции, которая должна точно соответствовать ожидаемой ndimage.

Выше мы scipy.LowLevelCallableуказывали, user_dataчто мы создали с помощью ctypes.

Другой подход заключается в предоставлении данных в контексте капсулы, которые можно установить с помощью : cfunc: `PyCapsule_SetContext` и не указывать user_dataв scipy.LowLevelCallable. Однако в этом подходе нам нужно иметь дело с распределением / освобождением данных - освобождение данных после разрушения капсулы можно сделать, указав функцию обратного вызова, отличную от NULL, в третьем аргументе : cfunc: `PyCapsule_New` .

Функции обратного вызова C для ndimageвсех следуют этой схеме. В следующем разделе перечислены ndimageфункции, которые принимают функцию обратного вызова C, и приведен прототип функции.

Смотрите также 
Функции, которые поддерживают аргументы обратного вызова низкого уровня:

generic_filter, generic_filter1d,geometric_transform

Ниже мы покажем альтернативные способы написания кода, используя Cython , ctypes или cffi вместо написания кода-обертки на C.
	</p>
	
Numba
	<p>
Numba предоставляет способ легко писать низкоуровневые функции в Python. Мы можем написать выше, используя Numba как:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 # example.py
import numpy as np
import ctypes
from scipy import ndimage , LowLevelCallable
from numba import cfunc , types , carray

@cfunc ( types . intc ( types . CPointer ( types . intp ),
                  types . CPointer ( types . double ),
                  types . intc ,
                  types . intc ,
                  types . voidptr ))
def transform ( output_coordinates_ptr , input_coordinates_ptr ,
              output_rank , input_rank , user_data ):
    input_coordinates = carray ( input_coordinates_ptr , ( input_rank ,))
    output_coordinates = carray ( output_coordinates_ptr , ( output_rank ,))
    shift = carray ( user_data , ( 1 ,), types . double )[ 0 ]

    for i in range ( input_rank ):
        input_coordinates [ i ] = output_coordinates [ i ] - shift

    return 1

shift = 0.5

# Then call the function
user_data = ctypes . c_double ( shift )
ptr = ctypes . cast ( ctypes . pointer ( user_data ), ctypes . c_void_p )
callback = LowLevelCallable ( transform . ctypes , ptr )

im = np . arange ( 12 ) . reshape ( 4 , 3 ) . astype ( np . float64 )
print ( ndimage . geometric_transform ( im , callback ))
	</pre>
	</div>


Cython
	
	<p>
Функционально тот же код, что и выше, может быть написан на Cython с несколько меньшими шаблонами, как показано ниже.
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 # example.pyx

from numpy cimport npy_intp as intp

cdef api int transform ( intp * output_coordinates , double * input_coordinates ,
                       int output_rank , int input_rank , void * user_data ):
    cdef intp i
    cdef double shift = ( < double *> user_data )[ 0 ]

    for i in range ( input_rank ):
        input_coordinates [ i ] = output_coordinates [ i ] - shift
    return 1
 # script.py

import ctypes
import numpy as np
from scipy import ndimage , LowLevelCallable

import example

shift = 0.5

user_data = ctypes . c_double ( shift )
ptr = ctypes . cast ( ctypes . pointer ( user_data ), ctypes . c_void_p )
callback = LowLevelCallable . from_cython ( example , "transform" , ptr )
im = np . arange ( 12 ) . reshape ( 4 , 3 ) . astype ( np . float64 )
print ( ndimage . geometric_transform ( im , callback ))
cffi
		</pre>
	</div>

	<p>
С cffi вы можете взаимодействовать с функцией C, находящейся в общей библиотеке (DLL). Во-первых, нам нужно написать разделяемую библиотеку, что мы делаем на C - этот пример для Linux / OSX:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: plain">		
 /*
  example . c
  Needs to be compiled with "gcc -std=c99 -shared -fPIC -o example.so example.c"
  or similar
 */

#include <stdint.h>

int
_transform ( intptr_t * output_coordinates , double * input_coordinates ,
           int output_rank , int input_rank , void * user_data )
{
    int i ;
    double shift = * ( double * ) user_data ;

    for ( i = 0 ; i < input_rank ; i ++ ) {
        input_coordinates [ i ] = output_coordinates [ i ] - shift ;
    }
    return 1 ;
}
	</pre>
	</div>

	<p>
Код Python, вызывающий библиотеку:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 import os
import numpy as np
from scipy import ndimage , LowLevelCallable
import cffi

# Construct the FFI object, and copypaste the function declaration
ffi = cffi . FFI ()
ffi . cdef ( """
int _transform(intptr_t *output_coordinates, double *input_coordinates,
               int output_rank, int input_rank, void *user_data);
""" )

# Open library
lib = ffi . dlopen ( os . path . abspath ( "example.so" ))

# Do the function call
user_data = ffi . new ( 'double *' , 0.5 )
callback = LowLevelCallable ( lib . _transform , user_data )
im = np . arange ( 12 ) . reshape ( 4 , 3 ) . astype ( np . float64 )
print ( ndimage . geometric_transform ( im , callback ))
		</pre>
	</div>

	<p>
Вы можете найти больше информации в документации CFFI .
	</p>
	
ctypes
	<p>
С ctypes код C и компиляция so / DLL такие же, как для cffi выше. Код Python отличается:
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
 # script.py

import os
import ctypes
import numpy as np
from scipy import ndimage , LowLevelCallable

lib = ctypes . CDLL ( os . path . abspath ( 'example.so' ))

shift = 0.5

user_data = ctypes . c_double ( shift )
ptr = ctypes . cast ( ctypes . pointer ( user_data ), ctypes . c_void_p )

# Ctypes has no built-in intptr type, so override the signature
# instead of trying to get it via ctypes
callback = LowLevelCallable ( lib . _transform , ptr ,
    "int _transform(intptr_t *, double *, int, int, void *)" )

# Perform the call
im = np . arange ( 12 ) . reshape ( 4 , 3 ) . astype ( np . float64 )
print ( ndimage . geometric_transform ( im , callback ))
	</pre>
	</div>

	<p>
Вы можете найти больше информации в документации по ctypes .
	</p>
	

</div>

<div class="section" id="id10">
<h4>Ссылки</h4>
	<p>
[1]	М. Унсер, «Сплайны: идеальная подгонка для обработки сигналов и изображений», IEEE Signal Processing Magazine, vol. 16, вып. 6, с. 22-38, ноябрь 1999 г.
[2]	Г. Боргефорс, «Дистанционные преобразования в доступных измерениях», «Компьютерное зрение», «Графика и обработка изображений», 27: 321-345, 1984.
[3]	К.Р. Маурер-младший, Р. Ци, В. Рагхаван, «Линейный алгоритм времени для вычисления точных евклидовых дистанционных преобразований двоичных изображений в используемых измерениях. IEEE Trans. PAMI 25, 265-270, 2003.
[4]	П. Фелкель, Р. Вегенкиттль и М. Брукшвайгер, «Eurographics 2001, p. C: 26-35,« Внедрение и сложность алгоритма водораздела от маркеров, вычисленных как минимальная стоимость леса ».
	</p>
</div>


</div>


</div>

</div>	
		 


<!-- Footer Start -->
<div class="col-md-12 page-body margin-top-50 footer">
  <footer>
  <ul class="menu-link">
	   <li><a href="index.html">Содержание</a></li>
	   <li><a href="about.html">О сайте</a></li>
	</ul>
	
  <p>© Copyright 2016 DevBlog. All rights reserved</p>
  
						  
  <!-- UiPasta Credit Start -->
  <div class="uipasta-credit">Design By <a href="http://www.uipasta.com" target="_blank">UiPasta</a></div>
  <!-- UiPasta Credit End -->
  
   
 </footer>
</div>
 <!-- Footer End -->
 
</div>
</div>

   
</div>
</div>
</div>

<!-- Blog Post (Right Sidebar) End -->
    
    
    <!-- Back to Top Start -->
    <a href="#" class="scroll-to-top"><i class="fa fa-long-arrow-up"></i></a>
    <!-- Back to Top End -->
    
    
    <!-- All Javascript Plugins  -->
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/plugin.js"></script>
    
    <!-- Main Javascript File  -->
    <script type="text/javascript" src="js/scripts.js"></script>
    
    <!-- Syntax Highlighter Javascript File  -->
    <script type="text/javascript" src="js/syntax/shCore.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushCss.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushJScript.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPerl.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPhp.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPlain.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPython.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushRuby.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushSql.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushVb.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushXml.js"></script>
    
	<!-- Syntax Highlighter Call Function -->
	<script type="text/javascript">
		SyntaxHighlighter.config.clipboardSwf = 'js/syntax/clipboard.swf';
		SyntaxHighlighter.all();
	</script>

    
   </body>
 </html>
