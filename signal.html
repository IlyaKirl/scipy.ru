<!DOCTYPE html>
<html lang="en">

  <head>
    
    <!-- Meta Tag -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <!-- SEO -->
    <meta name="description" content="учебник scipy, пакет программ для научных вычислений, специальные функции, интегрирование, оптимизация, интерполяция, преобразования Фурье, цифровая обработка сигналов, линейная алгебра, проблема собственных значений разреженных матриц, алгоритмы на разреженных графах, пространственные структуры данных и алгоритмы, статистика, обработка многомерных данных, numpy">
    <meta name="author" content="labintsevai">
    <meta name="url" content="http://www.scipy-tutorial.ru">
    <meta name="copyright" content="labintsevai">
    <meta name="robots" content="index,follow">
    
	<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(51612041, "init", {
        id:51612041,
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/51612041" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
    
    <title>SciPy Цифровая обработка сигналов</title>
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon/favicon.ico">
    <link rel="apple-touch-icon" sizes="144x144" type="image/x-icon" href="images/favicon/apple-touch-icon.png">
    
    <!-- All CSS Plugins -->
    <link rel="stylesheet" type="text/css" href="css/plugin.css">
    
    <!-- Main CSS Stylesheet -->
    <link rel="stylesheet" type="text/css" href="css/style.css">
    
    <!-- Google Web Fonts  -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins:400,300,500,600,700">
    
    <!-- Syntax Highlighter  -->
    <link rel="stylesheet" type="text/css" href="css/syntax/shCore.css">
    <link rel="stylesheet" type="text/css" href="css/syntax/shThemeDefault.css">
    
        	<!-- MathJax support-->
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async>
</script>

    <!-- HTML5 shiv and Respond.js support IE8 or Older for HTML5 elements and media queries -->
    <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    

  </head>

 <body>

	<!-- Preloader Start -->
     <div class="preloader">
	   <div class="rounder"></div>
      </div>
      <!-- Preloader End -->
      
      
    
    
<div id="main">
<div class="container">
<div class="row">

<!-- About Me (Left Sidebar) Start -->
<div class="col-md-3">
<div class="about-fixed">

<div class="my-pic">
<img src="images/pic/scipyLogo.png" alt="">
</div>



<div class="my-detail">

<div class="white-spacing">
	<h1><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/index.html">SciPy.org</a></h1>
	<span>Научные вычисления</span>
</div> 

<ul class="social-icon">
 <li><a href="https://www.facebook.com/scipyconf" target="_blank" class="facebook"><i class="fa fa-facebook"></i></a></li>
 <li><a href="https://twitter.com/hashtag/scipy" target="_blank" class="twitter"><i class="fa fa-twitter"></i></a></li>
<li><a href="https://github.com/scipy" target="_blank" class="github"><i class="fa fa-github"></i></a></li>
</ul>

</div>
</div>
</div>
<!-- About Me (Left Sidebar) End -->

<!-- Blog Post (Right Sidebar) Start -->
<div class="col-md-9">
<div class="col-md-12 page-body">
<div class="row">
	
<div class="sub-title">
	<h2><a href="index.html">Содержание</h2></a>
 </div>

<div class="col-md-12 content-page">
	<div class="col-md-12 blog-post">

	<!-- Post Headline Start -->
	<div class="post-title">
	<ul class="simple">
	<h4>Цифровая обработка сигналов (scipy.signal) </h4>
	<li><a class="reference internal" href="#id1">B-сплайны </a></li>
	<li><a class="reference internal" href="#id2">Фильтрация  </a>
		<ul><li>Вычисление свертки и корреляции</li>
		<li>Разностные уравнения в цифровой фильтрации <ul>
			<li>Анализ линейных систем </li>
		</ul></li>
		<li>Разработка цифровых фильтров <ul>
			<li>Фильтры с конечной импульсной характеристикой (КИХ, FIR) </li>
			<li>Фильтры с бесконечной импульсной характеристикой (БИХ, IIR) </li>
			<li>Коэффициенты фильтров </li>
			<li>Преобразования при фильтрации </li>
		</ul></li>
		<li>Виды цифровых фильтров <ul>
			<li>Медианный фильтр </li>
			<li>Фильтр общего порядка</li>
			<li>Фильтр Винера</li>
			<li>Фильтр Гильберта</li>
		</ul></li>
		<li>Разработка аналоговых фильтров </li>
		</ul>
	</li>
	<li><a class="reference internal" href="#id3">Спектральный анализ </a></li>
		<ul><li>Измерение периодограмм</li>
		<li>Спектральный анализ методом Уолша</li>
		<li>Периодограммы Lomb-Scarlage </li>
		</ul>
	<li><a class="reference internal" href="#id4">Исключение постоянной составляющей </a></li>
	<li><a class="reference internal" href="#id5">Рекомендованная литература </a></li>
	</ul>	

	</div>
	   <!-- Post Headline End -->
	   

	<p>
Пакет обработки сигналов содержит некоторые функции фильтрации, небольшой набор инструментов для проектирования фильтров и несколько алгоритмов интерполяции B-сплайнами для одномерных и двумерных данных. Технически алгоритмы B-сплайнов должны быть размещены в категории интерполяции. Однако они включены здесь, потому что работают только с равномерными отсчетами данных, а также хорошо описываются терминами теории фильтрации и передаточных функций. <br>
Перед чтением раздела нужно обратить внимание, что цифровой сигнал в SciPy представляется в виде массива действительных или комплексных чисел.
	</p>

<div class="section" id="id1">
<h3>B-сплайны</h3>
	<p>
B-сплайн - это один из способов упрощенного представления непрерывной функции, заданной в виде конечного числа отсчетов, в виде B-сплайн-коэффициентов и узловых точек. Если узлы расположены равномерно с интервалом \( \Delta x \), то аппроксимация B-сплайном одномерной функции является разложением на основе конечного базиса.

$$ y\left(x\right)\approx\sum_{j}c_{j}\beta^{o}\left(\frac{x}{\Delta x}-j\right). $$

Для двумерной функции с узловым интервалом \( \Delta x \) и \( \Delta y \) В-сплайн аппроксимация имеет вид

$$ z\left(x,y\right)\approx\sum_{j}\sum_{k}c_{jk}\beta^{o} \left(\frac{x}{\Delta x}-j\right)\beta^{o}\left(\frac{y}{\Delta y}-k\right). $$ 

В этих выражениях \( \beta^{o} \left (\cdot \right) \) является B-сплайн базисной функцией порядка \( o \). Если исходные данные и узловые точки расположены с равным интервалом, это позволяет разрабатывать быстрые  алгоритмы для определения коэффициентов \( c_{j} \) на основе значений выборки  \(y_{n} \). В отличие от общих алгоритмов интерполяции сплайнами, эти алгоритмы позволяют быстро найти сплайн-коэффициенты для больших данных.
<br>
Преимуществом представления функции через базисные функции B-сплайна состоит в том, что непрерывные операторы (производная, передискретизация, интеграл и т.д.), легко вычисляются через сплайн-коэффициенты. Например, вторая производная сплайна

$$ y{}^{\prime\prime}\left(x\right)=\frac{1}{\Delta x^{2}}\sum_{j}c_{j}\beta^{o\prime\prime}\left(\frac{x}{\Delta x}-j\right). $$

Используя свойство B-сплайнов,

$$ \frac{d^{2}\beta^{o}\left(w\right)}{dw^{2}}=\beta^{o-2}\left(w+1\right)-2\beta^{o-2}\left(w\right)+\beta^{o-2}\left(w-1\right) $$

можно видеть, что

$$ y^{\prime\prime}\left(x\right)=\frac{1}{\Delta x^{2}}\sum_{j}c_{j}\left[\beta^{o-2}\left(\frac{x}{\Delta x}-j+1\right)-2\beta^{o-2}\left(\frac{x}{\Delta x}-j\right)+\beta^{o-2}\left(\frac{x}{\Delta x}-j-1\right)\right]. $$

Если \( o = 3 \), то в точках выборки,

$$ \Delta x^2 y' (x) |_{x=n \Delta x} = \sum_j c_j \delta_{n-j+1} - 2c_j \delta_{n-j} + c_j \delta_{n-j-1} = $$
$$ = c_{n+1} -2c_n + c_{n-1}. $$

Таким образом, сигнал второй производной можно легко вычислить из исходного сигнала, аппроксимированного В-сплайном. При желании можно использовать сглаживающие сплайны, чтобы сделать вторую производную менее чувствительной к случайным ошибкам.
<br>
Внимательный читатель уже заметил, что выборки данных связаны с узловыми коэффициентами посредством оператора свертки. Таким образом, восстанавить исходные данные из сплайн-коэффициентов можно с помощью простой свертки с дискретной B-сплайн функцией . Выход свертки может меняться в зависимости от того, как обрабатываются границы (это становится более важным по мере увеличения количество измерений в выборке). Алгоритмы B-сплайн в пакете обработки scipy.signal предполагают зеркально-симметричные граничные условия. Таким образом, сплайн-коэффициенты вычисляются на основе этого предположения, и выборка данных могут быть восстановлена точно из сплайн-коэффициентов, предполагая их также зеркально-симметричными.
<br>
В настоящее время пакет scipy.signal содержит функции для определения кубических сплайн-кодов второго и третьего порядка из равномерных выборок функции одного или двух переменных (qspline1d, qspline2d, cspline1d, cspline2d). Пакет также предоставляет функцию bspline для вычисления базовой функции bspline \( \beta^{o} \left (x \right) \) произвольного порядка и любого \( x \). Для больших \( o \) базисная функция B-сплайна может быть хорошо аппроксимирована нормальной функцией Гаусса со стандартным отклонением, равным \( \sigma_{o} = \left (o + 1 \right) / 12 \):

$$ \beta^{o}\left(x\right)\approx\frac{1}{\sqrt{2\pi\sigma_{o}^{2}}}\exp\left(-\frac{x^{2}}{2\sigma_{o}}\right). $$

Также доступна функция для вычисления гауссова сплайна для любых \( x и o \) gauss_spline. В коде из примера ниже и на рисунке используется spline-фильтрация для вычисления второй производной сглаженного сплайна. В качестве входных данных использовано лица енота, которое является массивом, возвращаемым командой: misc.face. Команда: sepfir2d использовалась для применения разделимого двумерного КИХ-фильтра с зеркально-симметричными граничными условиями к сплайн-коэффициентам. Эта функция идеально подходит для восстановления выборки из сплайн-коэффициентов. Она работает быстрее, чем convolve2d, которая свертывает произвольные двумерные фильтры и позволяет выбирать зеркально-симметричные граничные условия.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> from scipy import signal, misc
   >>> import matplotlib.pyplot as plt

   >>> image = misc.face(gray=True).astype(np.float32)
   >>> derfilt = np.array([1.0, -2, 1.0], dtype=np.float32)
   >>> ck = signal.cspline2d(image, 8.0)
   >>> deriv = (signal.sepfir2d(ck, derfilt, [1]) +
   ...          signal.sepfir2d(ck, [1], derfilt))
	</pre>
	</div>

	<p>
   В качестве альтернативы можно сделать так:
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
laplacian = np.array([[0,1,0], [1,-4,1], [0,1,0]], dtype=np.float32)
deriv2 = signal.convolve2d(ck,laplacian,mode='same',boundary='symm')

>>> plt.figure()
>>> plt.imshow(image)
>>> plt.gray()
>>> plt.title('Original image')
>>> plt.show()
	</pre>
	</div>
<img src="img/signal-1-1.png">
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
>>> plt.figure()
>>> plt.imshow(deriv)
>>> plt.gray()
>>> plt.title('Output of spline edge filter')
>>> plt.show()
	</pre>
	</div>
<img src="img/signal-1-2.png">
	</div>
	
<div class="section" id="id2">
<h3>Фильтрация</h3>
	<p>
Фильтр - это общее название для любой системы, которая каким-то образом преобразует входной сигнал в выходной. В SciPy сигнал представляется как массив NumPy. Для различных видов операций существуют различные виды фильтров. Два основных вида фильтрующих операций: линейный и нелинейный. Линейные фильтры всегда можно свести к умножению одномерного массива NumPy на соответствующую матрицу, что на выходе даст одномерный массив NumPy. Конечно, это обычно не лучший способ вычислить фильтрацию, поскольку вовлеченные матрицы и векторы могут быть огромными. Например, для фильтрации изображения 512 на 512 пикселей с помощью этого метода потребуется умножение матрицы \( 512 ^ 2 \times 512 ^ 2 \) с вектором \( 512 ^ 2 \). Просто попытка сохранить матрицу \( 512 ^ 2 \times 512 ^ 2 \) с использованием стандартного массива NumPy потребует 68 719 476 736 элементов. При 4 байтах на элемент для этого потребуется 256  GB памяти. В большинстве приложениях многие элементы этой матрицы равны нулю, поэтому используется менее затратный метод вычисления выхода фильтра.
	</p>
	
<h4>Вычисление свертки и корреляции</h4>
	
	<p>
Многие линейные фильтры обладают свойством сдвиговой инвариантности. Это означает, что операция фильтрации одинакова в разных местах сигнала. Следовательно, матрица фильтрации может быть построена на основе только одной строки (или столбца). В этом случае матричное умножение может быть выполнено с использованием преобразований Фурье.

Пусть \( x\left[n\right] \) определяет отсчеты одномерного сигнала, проиндексированные целым числом n. Полная свертка двух одномерных сигналов может быть выражена как

$$ y\left[n\right]=\sum_{k=-\infty}^{\infty}x\left[k\right]h\left[n-k\right]. $$

Это уравнение может быть реализовано непосредственно, если ограничить последовательности конечными опорными последовательностями, которые могут быть сохранены в компьютере. Выберем \( n = 0 \) как отправную точку обеих последовательностей. Пусть \( K + 1 \) - это значение, для которого \( x \left[ n \right] = 0 \) для всех \( n \geq K + 1 \).  \( M + 1 \) - это значение, для которого \( h [ n ] = 0 \) для всех \( n \geq M + 1 \). Тогда дискретная свертка определяется выражением

$$ y\left[n\right]=\sum_{k=\max\left(n-M,0\right)}^{\min\left(n,K\right)}x\left[k\right]h\left[n-k\right]. $$

Для удобства предположим, что \( K \geq M \). Тогда, более явный вывод этой операции имеет вид

$$ y[0] = x[0] h[0] $$
$$ y[1] = x[0] h[1] + x[1] h[0] $$
$$ y[1] = x[0] h[2] + x[1] h[1] + x[2]h[0] $$
$$ ... $$
$$ y[M] = x[0] h[M] + x[1] h[M-1] + ... + x[M]h[0] $$
$$ y[M+1] = x[1] h[M] + x[2] h[M-1] + ... + x[M+1]h[0] $$
$$ ... $$
$$ y[K] = x[K-M] h[M] + ... + x[K]h[0] $$
$$ y[K+1] = x[K+1-M] h[M] + ... + x[K]h[1] $$
$$ ... $$
$$ y[K+M-1] = x[K-1] h[M] + x[K]h[M-1] $$
$$ y[K+M] = x[K] h[M] $$

Таким образом, полная дискретная свертка двух конечных последовательностей длин \( K + 1 \) и \( M + 1 \) соответственно приводит к конечной последовательности длины \( K + M + 1 = (K + 1 ) + (M + 1 ) - 1 \).

Одномерная свертка реализована в SciPy с помощью функции: convolve. Эта функция принимает в качестве входных сигналов сигналы \( x, h \) и два необязательных параметра mode и method, возвращает сигнал \( y \) .

Первый необязательный флаг mode позволяет указать, какая часть выходного сигнала должна возвращаться. Значение по умолчанию «full» возвращает весь сигнал. Если флаг имеет значение «same», то возвращаются только K средних значений, начиная с \( y [ \lfloor \frac {M-1} {2}  \rfloor ] \), т.о. выход имеет такую же длину, что и входная последовательность. Если флаг имеет значение «valid», то возвращаются только \( K-M + 1 =  (K + 1 ) -  (M + 1 ) +1 \) средних значений, где z зависит от всех значений наименьшего входа от \( h [0 ] \) до \( h [M ] \). Другими словами, возвращаются только значения от \( y [M ] \) до \( y [K ] \) включительно.
<br>
Второй необязательный флаг «method» определяет метод вычисления свертки. fftconvolve задействует преобразование Фурье, прямой метод определяется значением direct. По умолчанию он выбирает ожидаемый более быстрый метод. Метод преобразования Фурье имеет порядок вычислительной сложности \( O (N \ log N) \), а прямой метод имеет порядок \( O (N ^ 2) \). В зависимости от величины константы \( O \) и значения \( N \) один из этих двух методов может быть быстрее. Значение по умолчанию «auto» выполняет предварительный расчет и выбирает ожидаемый более быстрый метод, в то время как значения «direct» и «fft» вычисляют свертку с помощью соответствующих методов.
<br>
В коде ниже показан простой пример свертки двух последовательностей
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
>>> x = np.array ([1.0, 2.0, 3.0])
>>> h = np.array ([0.0, 1.0, 0.0, 0.0, 0.0])
>>> signal.convolve (x, h)
array ([0., 1., 2., 3., 0., 0., 0.])
>>> signal.convolve (x, h, 'same')
array ([2., 3., 0.])
	</pre>
	</div>

	<p>
Эта же функция convolve также может принимать N-мерные массивы в качестве входов и вычислять N-мерную свертку двух массивов, как показано в приведенном ниже примере кода. В этом случае доступны все те же флаги.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
>>> x = np.array ([[1., 1., 0., 0.], [1., 1., 0., 0.], [0., 0., 0., 0. ], [0., 0., 0., 0.]])
>>> h = np.array ([[1., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 1., 0. ], [0., 0., 0., 0.]])
>>> signal.convolve (x, h)
array ([[1., 1., 0., 0., 0., 0., 0],
       [1., 1., 0., 0., 0., 0., 0.],
       [0., 0., 1., 1., 0., 0., 0.],
       [0., 0., 1., 1., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0.]])
	</pre>
	</div>

	<p>
Вычисление корреляции очень похоже на свертку, за исключением того, что знак минус меняется на плюс. Таким образом, выражение

$$ w\left[n\right]=\sum_{k=-\infty}^{\infty}y\left[k\right]x\left[n+k\right] $$

называется (cross, взаимной) корреляцией сигналов \( y \) и \( x \). Для сигналов конечной длины с \( y [n ] = 0 \) вне диапазона \( [0, K ] \) и \( x [n ] = 0 \) вне диапазона \( [0, M] \), суммирование можно упростить

$$ w\left[n\right]=\sum_{k=\max\left(0,-n\right)}^{\min\left(K,M-n\right)}y\left[k\right]x\left[n+k\right]. $$

Предполагая снова, что \( K \geq M \), имеем подробную форму вычисления корреляции

$$ w[-K] = y[K] x[0] $$
$$ w[-K+1] = y[K-1] x[0] + y[K] x[1] $$
$$ ... $$
$$ w[M-K] = y[K-M] x[0] + y[K-M+1] x[1] + ... + y[K]x[M] $$
$$ w[M-K+1] = y[K-M-1] x[0] + ... + y[K-1]x[M] $$
$$ ... $$
$$ w[-1] = y[1] x[0] + y[2]x[1] + ... + y[M+1]x[M] $$
$$ w[ 0] = y[0] x[0] + y[1]x[1] + ... + y[M  ]x[M] $$
$$ w[ 1] = y[0] x[1] + y[1]x[2] + ... + y[M-1]x[M] $$
$$ w[ 2] = y[0] x[2] + y[1]x[3] + ... + y[M-2]x[M] $$
$$ ... $$
$$ w[M-1] = y[0] x[M-1] + y[1]x[M] $$
$$ w[M] = y[0] x[M] $$

В SciPy эту операцию реализует функция correlate. Для нее доступны эквивалентные флаги опций. Чтобы вернуть полную последовательность длины \( K + M + 1 \) - режим «full». Для возврата последовательности с тем же размером, что и самая большая последовательность, начинающаяся с \( w [-K + \lfloor \frac {M -1} {2} \rfloor ] \) - режим same. Для  возврата последовательности, в которой значения зависят от всех значений наименьшей последовательности - режим valid. Эта окончательная опция возвращает \( K-M + 1 \) значений \( w [M-K ] \) до \( w [0 ] \) включительно.
<br>
Функция correlate также может использоваться для вычисления корреляции N-мерных массивов.
<br>
В случае \( N = 2 \), функция correlate и / или convolve может использоваться для создания произвольных фильтров изображений. Можно выполнить такие операции обработки, как размытие, усиление и обнаружение границ изображения.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
>>> import numpy as np
>>> from scipy import signal, misc
>>> import matplotlib.pyplot as plt

>>> image = misc.face(gray=True)
>>> w = np.zeros((50, 50))
>>> w[0][0] = 1.0
>>> w[49][25] = 1.0
>>> image_new = signal.fftconvolve(image, w)

>>> plt.figure()
>>> plt.imshow(image)
>>> plt.gray()
>>> plt.title('Original image')
>>> plt.show()
	</pre>
	</div>
	
<img src="img/signal-2-1.png">

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
>>> plt.figure()
>>> plt.imshow(image_new)
>>> plt.gray()
>>> plt.title('Filtered image')
>>> plt.show()
	</pre>
	</div>
	
<img src="img/signal-2-2.png">

	<p>
Вычисление свертки во временной области, как было сказано выше,  используется для фильтрации, когда один из сигналов намного меньше другого \( (K \gg M) \). В противном случае линейная фильтрация более эффективно вычисляется в частотной области с помощью fftconvolve. По умолчанию convolve выбирает самый быстрый метод, используя  choose_conv_method.
<br>
Если функцию фильтра \( w [n, m] \) можно разложить 

$$ h [n, m] = h_1 [n] h_2 [m], $$

свертку можно вычислить с помощью функции sepfir2d. В качестве примера рассмотрим гауссовский фильтр gaussian

$$ h [n, m] \propto e ^ {- x ^ 2-y ^ 2} = e ^ {- x ^ 2} e ^ {- y ^ 2} $$

который часто используется для получения эффекта размытия.
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> from scipy import signal, misc
   >>> import matplotlib.pyplot as plt

   >>> image = misc.ascent()
   >>> w = signal.gaussian(50, 10.0)
   >>> image_new = signal.sepfir2d(image, w, w)

   >>> plt.figure()
   >>> plt.imshow(image)
   >>> plt.gray()
   >>> plt.title('Original image')
   >>> plt.show()
	</pre>
	</div>
<img src="img/signal-3-1.png">

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> plt.figure()
   >>> plt.imshow(image_new)
   >>> plt.gray()
   >>> plt.title('Filtered image')
   >>> plt.show()
	</pre>
	</div>
<img src="img/signal-3-2.png">

<h4>Разностные уравнения в цифровой фильтрации</h4>
	
	<p>
Обобщенным классом линейных одномерных фильтров (включая фильтры свертки) - это фильтры, описываемые разностным уравнением

$$ \sum_{k=0}^{N}a_{k}y\left[n-k\right]=\sum_{k=0}^{M}b_{k}x\left[n-k\right] $$

где \( x [n ] \) - входная последовательность, а \( y [n ] \) - выходная последовательность. Если мы представим начальное состояние так, что \( y [n ] = 0 \) при \( n < 0 \), то этот вид фильтра может быть реализован с использованием свертки. Однако последовательность сверточного фильтра \( h [n ] \) может быть бесконечной, если \( a_{k} \neq 0 \)  для \( k \geq 1 \). Кроме того, этот общий класс линейных фильтров позволяет устанавливать начальные условия  \( y [n ] \) при \( n < 0 \), что приводит к тому, что фильтр нельзя описать с помощью свертки.
<br>
Фильтр, описываемый разностным уравнением, можно рассматривать как рекурсивное вычисление \( y [n ] \)  в терминах предыдущих значений

$$ a_{0}y\left[n\right]=-a_{1}y\left[n-1\right]-\cdots-a_{N}y\left[n-N\right]+\cdots+b_{0}x\left[n\right]+\cdots+b_{M}x\left[n-M\right]. $$

Обычно для нормализации выбирается \( a_{0} = 1 \). Реализация в SciPy этого общего фильтра с форме разностных уравнений немного сложнее, чем предыдущее уравнение. Фильтр реализован так, что нужно использовать задержку только одиного сигнала. Уравнения реализации фильтра (при условии, что \( a_{0} = 1 \) ).

$$       y[n] = b_0     x[n] + z_0     [n-1] $$
$$     z_0[n] = b_1     x[n] + z_1     [n-1] - a_1     y[n] $$
$$     z_0[n] = b_2     x[n] + z_2     [n-1] - a_2     y[n] $$
$$ ...														$$
$$ z_{K-2}[n] = b_{K-1} x[n] + z_{K-1} [n-1] - a_{K-1} y[n] $$
$$ z_{K-1}[n] = b_{K  } x[n] 				 - a_{K}   y[n] $$


где \( K = \max (N, M ) \). Заметим, что \( b_{K} = 0 \), если \( K > M \) и \( a_{K} = 0 \), если \( K > N \). Таким образом, выход в момент времени \( n \) зависит только от входа в момент времени \( n \) и значения \( z_{0} \) в предыдущее время. Это всегда можно вычислить, если K значений \( z_{0} [n-1 ] \ldots z_{K-1} [n-1 ] \) вычисляются и сохраняются на каждом шаге вычисления.
<br>
Фильтр в виде разностного уравнения в SciPy вызывается с помощью команды: lfilter. Эта команда принимает в качестве входов вектор \( b \), вектор \( a \), сигнал \( x \) и возвращает вектор \( y \) (той же длины, что и \( x \)), вычисленный с использованием приведенного выше уравнения. Если \( x \) является N-мерным, то фильтр вычисляется вдоль определенной в уравнении оси. При желании, можно заранее определить начальные условия, обеспечивающие вычисление значений от \( z_{0} [-1 ] \) до \( z_{K-1} [-1 ] \). Иначе предполагается, что они равны нулю. Если заданы начальные условия, то окончательные условия для промежуточных переменных вычисляются по ходу. Принудительное задание коэффициентов может использоваться, например, для перезапуска вычисления в том же состоянии.
<br>
Иногда удобнее выразить начальные условия в терминах сигналов \( x [n ] \) и \( y [n ] \). Другими словами, пусть известны значения от \( x [-M ] \) до \( x [-1 ] \) и значения от \( y [-N] \) до \( y [-1] \). Необходимо определить, какие значения \( z_{m} [-1 ] \) должны быть подставлены в разностное уравнение фильтра. Нетрудно показать, что при \( 0 \leq m &lt; K \),

$$ z_{m}\left[n\right]=\sum_{p=0}^{K-m-1}\left(b_{m+p+1}x\left[n-p\right]-a_{m+p+1}y\left[n-p\right]\right). $$

Используя эту формулу, мы можем найти все значения, от начального условия \( z_{0} [-1 ] \) до \( z_{K-1} [-1 ] \) при заданных начальных условиях \( y ; x \). Эта функция реализована с помощью процедуры lfiltic.
<br>
В качестве примера рассмотрим следующую систему:

$$ y[n] = \frac{1}{2} x[n] + \frac{1}{4} x[n-1] + \frac{1}{3} y[n-1] $$

Код для вычисления сигнала \( y [n] \) для заданного сигнала \( x [n] \) для начальных условий \( y [-1] = 0 \) (случай по умолчанию), затем для \( y [-1] = 2 \), приведен ниже
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
>>> import numpy as np
>>> from scipy import signal

>>> x = np.array([1., 0., 0., 0.])
>>> b = np.array([1.0/2, 1.0/4])
>>> a = np.array([1.0, -1.0/3])
>>> signal.lfilter(b, a, x)
array([0.5, 0.41666667, 0.13888889, 0.0462963])
>>> zi = signal.lfiltic(b, a, y=[2.])
>>> signal.lfilter(b, a, x, zi=zi)
(array([ 1.16666667,  0.63888889,  0.21296296,  0.07098765]), array([0.02366]))
	</pre>
	</div>

	<p>
Обратите внимание, что выходной сигнал \( y [n] \) имеет ту же длину, что и длина входного сигнала \( x [n] \).
	</p>
	
<h4>Анализ линейных систем</h4>
	
	<p>
Линейная система, описываемая линейным разностным уравнением, может быть полностью описана векторами коэффициентов \( a и b \), как это было сделано выше.  Альтернативным описания системы с помощью ее передаточной функции H (z) является предоставление в виде коэффициента \(k\), \(N_z\) нулей \(z_k\) и \(N_p\) полюсов \(p_k\) 

$$ H(z) = k \frac{ (z-z_1)(z-z_2)...(z-z_{N_z})}{ (z-p_1)(z-p_2)...(z-p_{N_p})} $$

Это представление можно получить с помощью функции: scipy.tf2zpk. Обратное преобразование обеспечивается функцией scipy.zpk2tf.
<br>
Для примера выше имеем разложение в виде системы, которая имеет нуль при \( z = -1 / 2 \) и полюс при \( z = 1/3 \)
	</p>
	
	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
>>> b = np.array ([1.0 / 2, 1.0 / 4])
>>> a = np.array ([1.0, -1.0 / 3])
>>> signal.tf2zpk (b, a)
(массив ([- 0,5]), массив ([0.33333333]), 0,5)
	</pre>
	</div>

	<p>
Функция scipy.freqz позволяет вычислять частотную характеристику системы, описываемой коэффициентами \(a_k и b_k \). Подробности см. в help(freqz).
	</p>
	
<h4>Разработка цифровых  фильтров</h4>
	<p>
Цифровые фильтры можно классифицировать на фильтры с конечным откликом (импульсной характеристикой, КИХ, FIR) и фильтры с бесконечным откликом (импульсной характеристикой, БИХ, IIR). Фильтры FIR могут обеспечить линейную фазовую характеристику, тогда как фильтры IIR не могут. SciPy предоставляет функции для проектирования обоих типов фильтров.
<br>
<strong>КИХ-фильтры</strong>
<br>
Функция firwin позволяет описывать фильтры оконным методом. В зависимости от предоставленных аргументов функция возвращает разные типы фильтров: low-pass (НЧ), high-pass (ВЧ), band-pass (полосовой).
<br>
В приведенном ниже примере представлены фильтры НЧ и полосы частот, соответственно.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> import scipy.signal as signal
   >>> import matplotlib.pyplot as plt

   >>> b1 = signal.firwin(40, 0.5)
   >>> b2 = signal.firwin(41, [0.3, 0.8])
   >>> w1, h1 = signal.freqz(b1)
   >>> w2, h2 = signal.freqz(b2)

   >>> plt.title('Digital filter frequency response')
   >>> plt.plot(w1, 20*np.log10(np.abs(h1)), 'b')
   >>> plt.plot(w2, 20*np.log10(np.abs(h2)), 'r')
   >>> plt.ylabel('Amplitude Response (dB)')
   >>> plt.xlabel('Frequency (rad/sample)')
   >>> plt.grid()
   >>> plt.show()
	</pre>
	</div>

<img src="img/signal-4.png">

	<p>
Обратите внимание: firwin использует по умолчанию нормированную частоту, определенную так, что значение 1 соответствует частоте Найквиста. Тогда как функция freqz определяется так, что частоте Найквиста соответствует значение \( \pi \).
<br>
Функция firwin2 позволяет создавать почти произвольные частотные отклики, задавая массив угловых частот и соответствующих им коэффициентов усиления.
<br>
В приведенном ниже примере представлен фильтр с таким произвольным амплитудным откликом.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> import scipy.signal as signal
   >>> import matplotlib.pyplot as plt

   >>> b = signal.firwin2(150, [0.0, 0.3, 0.6, 1.0], [1.0, 2.0, 0.5, 0.0])
   >>> w, h = signal.freqz(b)

   >>> plt.title('Digital filter frequency response')
   >>> plt.plot(w, np.abs(h))
   >>> plt.title('Digital filter frequency response')
   >>> plt.ylabel('Amplitude Response')
   >>> plt.xlabel('Frequency (rad/sample)')
   >>> plt.grid()
   >>> plt.show()
	</pre>
	</div>

<img src="img/signal-5.png">

	<p>
Обратите внимание на линейное масштабирование оси y и различное определение частоты Найквиста в функиях firwin2 и freqz (как объяснялось выше).
<br>
<strong>БИХ фильтры</strong>
<br>
SciPy предоставляет две функции для прямого проектирования БИХ фильтров: iirdesign и iirfilter. Тип фильтра (например, эллиптический) передается как аргумент. Также доступны еще несколько функций проектирования фильтров для конкретных типов, например ellip.
<br>
В приведенном ниже примере представлен эллиптический фильтр нижних частот с заданной полосой пропускания и подавления соответственно. Обратите внимание, что порядок фильтра (4) более низкий по сравнению с фильтрами FIR из приведенных выше примеров. Достигаемая величина затухания составляет около 60 дБ.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> import scipy.signal as signal
   >>> import matplotlib.pyplot as plt

   >>> b, a = signal.iirfilter(4, Wn=0.2, rp=5, rs=60, btype='lowpass', ftype='ellip')
   >>> w, h = signal.freqz(b, a)

   >>> plt.title('Digital filter frequency response')
   >>> plt.plot(w, 20*np.log10(np.abs(h)))
   >>> plt.title('Digital filter frequency response')
   >>> plt.ylabel('Amplitude Response [dB]')
   >>> plt.xlabel('Frequency (rad/sample)')
   >>> plt.grid()
   >>> plt.show()
	</pre>
	</div>
<img src="img/signal-6.png">

<h4>Коэффициенты фильтра</h4>

	<p>
Коэффициенты цифрового фильтра могут быть представлены в нескольких разных форматах:<br>
    'ba' или 'tf' = коэффициенты передаточной функции<br>
    'zpk' = нули, полюсы и общий коэффициент усиления<br>
    'ss' = представление в виде состояний системы <br>
    'sos' = коэффициенты передаточной функции секций второго порядка<br>

Такие функции как tf2zpk и zpk2ss могут конвертировать различные представления.
<br>
Представление передаточной функции
<br>
Формат представления передаточной функции ba или tf представляет собой 2-D кортеж \( (b, a) \), где \( b \) - массив размера M + 1 коэффициентов многочлена M-порядка в числителе, \(a\) - массив длины N + 1  коэффициентов  знаменателя, положительных убывающих степеней переменной передаточной функции. Таким образом, набор b = [b_0, b_1, ..., b_M] и a = [a_0, a_1, ..., a_N] описывает аналоговый фильтр формы:

$$ H(s) = \frac
{b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
{a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}
= \frac
{\sum_{i=0}^M b_i s^{(M-i)}}
{\sum_{i=0}^N a_i s^{(N-i)}}
$$

или дискретный во времени фильтр:
$$
H (z) = \frac
{b_0 z ^ M + b_1 z ^ {(M-1)} + \cdots + b_M}
{a_0 z ^ N + a_1 z ^ {(N-1)} + \cdots + a_N}
= \frac
{\sum_ {i = 0} ^ M b_i z ^ {(M-i)}}
{\sum_ {i = 0} ^ N a_i z ^ {(N-i)}}
$$

Эта форма многочленов с положительными степенями часто встречается в технике управления. Если M и N равны (что справедливо для всех фильтров билинейного преобразования), то дискретный во времени фильтр можно представить в эквивалентной форме «отрицательных степеней», предпочтительной в DSP:
$$
H (z) = \frac
{b_0 + b_1 z ^ {- 1} + \cdots + b_M z ^ {- M}}
{a_0 + a_1 z ^ {- 1} + \cdots + a_N z ^ {- N}}
= \frac
{\sum_ {i = 0} ^ M b_i z ^ {- i}}
{\sum_ {i = 0} ^ N a_i z ^ {- i}}
$$
Хотя это верно для обычных фильтров, в общем случае это не так. Если M и N не равны, то коэффициенты передаточной функции дискретного во времени фильтра сначала должны быть преобразованы в форму «положительных степеней», прежде чем полюсы и нули будут найдены.
<br>
Это представление страдает от числовых ошибок при более высоких порядках, поэтому, по возможножности, предпочтительны другие форматы.
Представление нулей и полюсов
<br>
Формат zpk представляет собой 3-D кортеж \( (z, p, k) \), где \(z\) - массив M-длины комплексных нулей передаточной функции z = [z_0, z_1, ..., z_ {M-1}] , \(p\) - массив N-длины комплексных полюсов передаточной функции p = [p_0, p_1, ..., p_ {N-1}], \(k\) - скалярный коэффициент усиления. Функция цифрового преобразования имеет вид:
$$
H (z) = k \cdot \frac
{(z - z_0) (z - z_1) \cdots (z - z _ {(M-1)})}
{(z - p_0) (z - p_1) \cdots (z - p _ {(N - 1)})}
= k \frac
{\prod_ {i = 0} ^ {M-1} (z - z_i)}
{\prod_ {i = 0} ^ {N-1} (z - p_i)}
$$

или аналоговой передаточной функции:
$$
H (s) = k \cdot \frac
{(s - z_0) (s - z_1) \cdots (s - z _ {(M-1)})}
{(s - p_0) (s - p_1) \cdots (s - p _ {(N - 1)})}
= k \frac
{\prod_ {i = 0} ^ {M-1} (s - z_i)}
{\prod_ {i = 0} ^ {N-1} (s - p_i)}
$$
Корни многочленов хранятся как массивы NumPy, порядок их следования не имеет значения; ([-1, -2], [-3, -4], 1) - тот же фильтр, что и ([-2, -1], [-4, -3], 1).
<br>
Представление в виде состояний системы
<br>
Формат state system (ss) представляет собой 4-D кортеж массивов (A, B, C, D), представляющих пространство состояний системы цифрового / дискретного во времени фильтра N-порядка:
$$ 
\mathbf {x} [k + 1] = A \mathbf {x} [k] + B \mathbf {u} [k] \\
\mathbf {y} [k] = C \mathbf {x} [k] + D \mathbf {u} [k]
$$
или непрерывной / аналоговой системы в виде:
$$
\dot {\mathbf {x}} (t) = A \mathbf {x} (t) + B \mathbf {u} (t) \\
\mathbf {y} (t) = C \mathbf {x} (t) + D \mathbf {u} (t)
$$
с входами P, Q выходами и N переменными состояния, где:
<br>
    x - вектор состояния<br>
    y - выходной вектор длины Q<br>
    u - входной вектор длины P<br>
    A - матрица состояний с формой (N, N)<br>
    B - входная матрица с формой (N, P)<br>
    C - выходная матрица с формой (Q, N)<br>
    D представляет собой прохожую или промежуточную матрицу с формой (Q, P). (В тех случаях, когда система не имеет прямого прохода, все значения в D равны нулю.)
<br>
State-space является наиболее общим и естественным представлением, которое позволяет описать систему с несколькими входами и множественными выводами (MIMO). Для данной передаточной функции имеется несколько представлений состояния. В частности, «контролируемая каноническая форма» и «наблюдаемая каноническая форма» имеют те же коэффициенты, что и представление tf, и, следовательно, тоже страдают от числовых ошибок.
<br>
Представление второго порядка
<br>
Формат second order sections (sos) представляет собой один 2D-массив в форме (n_sections, 6). Он представляет последовательность передаточных функций второго порядка, которые последовательно реализуют фильтр более высокого порядка с минимальной числовой ошибкой. Каждая строка соответствует представлению tf второго порядка, причем первые три столбца предоставляют коэффициенты числителя, а последние три - коэффициенты знаменателя:
$$
[b_0, b_1, b_2, a_0, a_1, a_2]
$$
Коэффициенты обычно нормализуются так, что \( a_0 \) всегда равно 1. Представление sos обычно не страдает от численных ошибок при вычислении с плавающей запятой, выход фильтра будет одинаковым.
	</p>
	
<h4>Преобразования при фильтрации</h4>
	<p>
Функции проектирования БИХ-фильтров сначала генерируют прототип аналогового фильтра НЧ с нормированной частотой среза 1 рад/сек. Затем он преобразуется в другие частоты и типы диапазонов, используя следующие замены преобразование типа:<br>
lp2lp \( s \rightarrow \frac {s} {\omega_0} \)<br>
lp2hp \( s \rightarrow \frac {\omega_0} {s} \)<br>
lp2bp \( s \rightarrow \frac {s ^ 2 + {\omega_0} ^ 2} {s \cdot \mathrm {BW}} \) <br>
lp2bs \( s \rightarrow \frac {s \cdot \mathrm {BW}} {s ^ 2 + {\omega_0} ^ 2} \) <br>

Здесь \( \omega_0 \) - новая частота среза, а \( \mathrm {BW} \) - полоса пропускания. Они сохраняют симметрию на логарифмической частотной оси.
<br>
Чтобы преобразовать преобразованный аналоговый фильтр в цифровой фильтр, используется преобразование: func: `bilinear`, что делает следующую замену:
$$
s \rightarrow \frac {2} {T} \frac {z - 1} {z + 1}
$$

где T - время выборки (обратная частоте дискретизации).
	</p>
	
<h4>Другие фильтры</h4>

	<p>
Медианный фильтр
<br>
Медианный фильтр обычно применяется, когда шум заметно не гауссовый или когда требуется сохранить края. Медианный фильтр работает, сортируя все значения пикселов массива в прямоугольной области, окружающей интересующую точку. В качестве значения для выходного массива используется среднее значение списка  соседних пикселей. Промежуточное среднее - это среднее значение массива в отсортированном списке соседних значений. Если в окрестности четное число элементов, то используется среднее двух соседних значений. Медианный фильтр общего назначения на N-мерных массивах реализован в процедуре medfilt. Специальная версия, которая работает только для двумерных массивов, доступна как функция medfilt2d.
<br>
Фильтры заданного порядка
<br>
Медианный фильтр является конкретным примером более общего класса фильтров, называемых фильтрами заданного порядка. Чтобы вычислить выход в определенном пикселе, все фильтры порядка используют значения массива в области, окружающей этот пиксель. Эти значения массива сортируются, а затем один из них выбирается как выходное значение. Для медианного фильтра в качестве выхода используется среднее значений массива. 
<br>
Фильтр общего порядка позволяет пользователю выбирать, какие из отсортированных значений будут использоваться в качестве выходных данных. Так, например, можно выбрать максимальное значение в списке или минимальное. Фильтр порядка кроме входного массива и маски области, принимает дополнительный аргумент, который определяет, какой из элементов в отсортированном списке значений массива должен использоваться в качестве выхода. Процедура для расчета фильтра заданного порядка - order_filter.
<br>
Фильтр Винера
<br>
Фильтр Винера является простым затухающим фильтром для шумоподавления изображений. В ScyPy реализован не фильтр Винера, описанный в задачах восстановления изображений. Вместо этого реализован простой, локально-средний фильтр. Пусть x - входной сигнал, тогда выход

$$ y=\left\{ \begin{array}{cc} \frac{\sigma^{2}}{\sigma_{x}^{2}}m_{x}+\left(1-\frac{\sigma^{2}}{\sigma_{x}^{2}}\right)x & \sigma_{x}^{2}\geq\sigma^{2},\\ m_{x} & \sigma_{x}^{2}<\sigma^{2},\end{array}\right.$$

где \( m_{x}\) - локальная оценка среднего и \( \sigma_{x} ^ {2} \) - локальная оценка дисперсии. Окно для этих оценок является необязательным входным параметром (по умолчанию \( 3 \times 3 \) ). Параметр \( \sigma ^ {2} \) является параметром порогового шума. Если \( \sigma \) не задано, то оно оценивается как среднее значение локальных дисперсий.
<br>
Фильтр Гильберта
<br>
Преобразование Гильберта преобразует действительный сигнал в комплекснозначный. Например, если \( x = cos \omega n \), то преобразование Гильберта \( y = \textrm {hilbert} (x) \) вернет (кроме краев) \( y = \exp  (j \omega n ) \) . В частотной области преобразование Гильберта обозначается как 
$$
Y = X \cdot H
$$
где H равно 2 для положительных частот, 0 для отрицательных частот и 1 для нулевых частот.
	</p>
	
<h4>Разработка аналоговых фильтров</h4>
	<p>
Функции проектирования фильтров iirdesign, iirfilter имеют флаг, который позволяет создавать аналоговые фильтры.
<br>
В приведенном ниже примере представлен аналоговый БИХ-фильтр, который получает полюсы и нули с помощью tf2zpk  и выстраивает их в сложную s-плоскость. Нули при \( \omega \approx 150 \) и \( \omega \approx 300 \) четко видны в амплитудной характеристике.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> import scipy.signal as signal
   >>> import matplotlib.pyplot as plt

   >>> b, a = signal.iirdesign(wp=100, ws=200, gpass=2.0, gstop=40., analog=True)
   >>> w, h = signal.freqs(b, a)

   >>> plt.title('Analog filter frequency response')
   >>> plt.plot(w, 20*np.log10(np.abs(h)))
   >>> plt.ylabel('Amplitude Response [dB]')
   >>> plt.xlabel('Frequency')
   >>> plt.grid()
   >>> plt.show()
	</pre>
	</div>

<img src="img/signal-7-1.png">

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> z, p, k = signal.tf2zpk(b, a)

   >>> plt.plot(np.real(z), np.imag(z), 'xb')
   >>> plt.plot(np.real(p), np.imag(p), 'or')
   >>> plt.legend(['Zeros', 'Poles'], loc=2)

   >>> plt.title('Pole / Zero Plot')
   >>> plt.ylabel('Real')
   >>> plt.xlabel('Imaginary')
   >>> plt.grid()
   >>> plt.show()
	</pre>
	</div>

<img src="img/signal-7-2.png">

	</div>

<div class="section" id="id3">
<h3>Спектральный анализ</h3>
<h4>Измерения периодограмм</h4>
	
	<p>
Процедура scipy.signal.periodogram реализует метод оценки спектральной плотности с использованием метода периодограмм.
<br>
В приведенном ниже примере вычисляется периодограмма синусоидального сигнала с белым гауссовским шумом.
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> import scipy.signal as signal
   >>> import matplotlib.pyplot as plt

   >>> fs = 10e3
   >>> N = 1e5
   >>> amp = 2*np.sqrt(2)
   >>> freq = 1270.0
   >>> noise_power = 0.001 * fs / 2
   >>> time = np.arange(N) / fs
   >>> x = amp*np.sin(2*np.pi*freq*time)
   >>> x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

   >>> f, Pwelch_spec = signal.welch(x, fs, scaling='spectrum')

   >>> plt.semilogy(f, Pwelch_spec)
   >>> plt.xlabel('frequency [Hz]')
   >>> plt.ylabel('PSD')
   >>> plt.grid()
   >>> plt.show()
	</pre>
	</div>
<img src="img/signal-8.png">

<h4>Спектральный анализ методом Уэлша</h4>

	<p>
Усовершенствованный метод, особенно в отношении помехоустойчивости, - это метод Уэлша, который реализуется с помощью scipy-функции welch.

В примере ниже с помощью метода Уэлша оценивается спектр сигнала с теми же параметрами, что и в примере выше. Заметьте, насколько ниже порог шума на спектрограмме. 

	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy как np
   >>> import scipy.signal as signal
   >>> import matplotlib.pyplot как plt

   >>> fs = 10e3
   >>> N = 1e5
   >>> amp = 2*np.sqrt(2)
   >>> freq = 1270.0
   >>> noise_power = 0.001 * fs / 2
   >>> time = np.arange(N) / fs
   >>> x = amp*np.sin(2*np.pi*freq*time)
   >>> x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

   >>> f, Pwelch_spec = signal.welch(x, fs, scaling='spectrum')

   >>> plt.semilogy(f, Pwelch_spec)
   >>> plt.xlabel('frequency [Hz]')
   >>> plt.ylabel('PSD')
   >>> plt.grid()
   >>> plt.show ()
	</pre>
	</div>
<img src="img/signal-9.png">

<h4>Периодограммы методом Lomb-Scarlage</h4>
	<p>
Спектральный анализ методом наименьших квадратов (LSSA) основан на вычислении разности сигнала и синусоид заданной частоты (схож с Фурье анализом). Однако, в отличии от Фурье-анализа, LSSA не завышает величину периодического шума в последовательностях большой длины.
<br>
LSSA метод хорош для спектрального анализа неравномерно расположенных отсчетов данных, а также обнаружения слабых периодических сигналов.

Пусть имеется временной ряд, содержащий \( N_{t} \) значений \( X_{j}\equiv X(t_{j}) \), где \( (j = 1, \ldots, N_{t}) \). Среднее значение сдвинуто и равно нулю, дисперсия также нормирована к единице. Тогда нормированная периодограмма Ломба-Скаргеля на частоте f равна

$$
P_{n}(f) \frac{1}{2}\left\{\frac{\left[\sum_{j}^{N_{t}}X_{j}\cos\omega(t_{j}-\tau)\right]^{2}}{\sum_{j}^{N_{t}}\cos^{2}\omega(t_{j}-\tau)}+\frac{\left[\sum_{j}^{N_{t}}X_{j}\sin\omega(t_{j}-\tau)\right]^{2}}{\sum_{j}^{N_{t}}\sin^{2}\omega(t_{j}-\tau)}\right\}.
$$

где  \( \omega \equiv 2\pi f \) - угловая частота. Зависимость частоты от временного смещения \( \tau  \) выражается формулой
$$
\tan 2\omega\tau = \frac{\sum_{j}^{N_{t}}\sin 2\omega t_{j}}{\sum_{j}^{N_{t}}\cos 2\omega t_{j}}.
$$

Функция lombscargle вычисляет периодограмму с использованием  модифицированного алгоритма Townsend [3]. Алгоритм позволяет вычислять периодограмму, используя только один проход по входным массивам для каждой частоты.
<br>
Уравнение может быть приведено к виду
$$
P_{n}(f) = \frac{1}{2}\left[\frac{(c_{\tau}XC + s_{\tau}XS)^{2}}{c_{\tau}^{2}CC + 2c_{\tau}s_{\tau}CS + s_{\tau}^{2}SS} + \frac{(c_{\tau}XS - s_{\tau}XC)^{2}}{c_{\tau}^{2}SS - 2c_{\tau}s_{\tau}CS + s_{\tau}^{2}CC}\right]
$$

а также

$$
\tan 2\omega\tau = \frac{2CS}{CC-SS}.
$$

где

$$
c_{\tau} = \cos\omega\tau,\qquad s_{\tau} = \sin\omega\tau
$$

Суммы равны

$$
XC = \sum_{j}^{N_{t}} X_{j}\cos\omega t_{j}\\
XS = \sum_{j}^{N_{t}} X_{j}\sin\omega t_{j}\\
CC = \sum_{j}^{N_{t}} \cos^{2}\omega t_{j}\\
SS = \sum_{j}^{N_{t}} \sin^{2}\omega t_{j}\\
CS = \sum_{j}^{N_{t}} \cos\omega t_{j}\sin\omega t_{j}.
$$

Для этого требуются \( N_{f}(2N_{t}+3) \) вычислений тригонометрической функции, дающие увеличение скорости вычисления порядка двух раз по сравнению с простой реализацией.
	</p>

	</div>
	
<div class="section" id="id4">
<h3>Исключение постоянной составляющей</h3>
	<p>
		
Scipy предоставляет функцию detrend для удаления постоянного или линейного тренда в выборке данных, чтобы увидеть эффект изменений более высокого порядка.

В приведенном ниже примере удаляется постоянный и линейный тренд полиномиального временного ряда 2-го порядка и строится график остальной составляющей сигнала. 
	</p>

	<div class="margin-top-40 margin-bottom-40">  
	<pre class="brush: python">
   >>> import numpy as np
   >>> import scipy.signal as signal
   >>> import matplotlib.pyplot as plt

   >>> t = np.linspace(-10, 10, 20)
   >>> y = 1 + t + 0.01*t**2
   >>> yconst = signal.detrend(y, type='constant')
   >>> ylin = signal.detrend(y, type='linear')

   >>> plt.plot(t, y, '-rx')
   >>> plt.plot(t, yconst, '-bo')
   >>> plt.plot(t, ylin, '-k+')
   >>> plt.grid()
   >>> plt.legend(['signal', 'const. detrend', 'linear detrend'])
   >>> plt.show()
	</pre>
	</div>
	<img src="img/signal-10.png">
</div>


<div class="section" id="id5">
<h3>Рекомендованная литература</h3>
	<p>
Some further reading and related software:<br>
[1]	N.R. Lomb "Least-squares frequency analysis of unequally spaced data", Astrophysics and Space Science, vol 39, pp. 447-462, 1976<br>
[2]	J.D. Scargle "Studies in astronomical time series analysis. II - Statistical aspects of spectral analysis of unevenly spaced data", The Astrophysical Journal, vol 263, pp. 835-853, 1982<br>
[3]	R.H.D. Townsend, "Fast calculation of the Lomb-Scargle periodogram using graphics processing units.", The Astrophysical Journal Supplement Series, vol 191, pp. 247-253, 2010
	</p>
	</div>


</div>
 
</div>

</div>	
		 


<!-- Footer Start -->
<div class="col-md-12 page-body margin-top-50 footer">
  <footer>
  <ul class="menu-link">
	   <li><a href="index.html">Содержание</a></li>
	   <li><a href="about.html">О сайте</a></li>
	</ul>
	
  <p>© Copyright 2016 DevBlog. All rights reserved</p>
  
						  
  <!-- UiPasta Credit Start -->
  <div class="uipasta-credit">Design By <a href="http://www.uipasta.com" target="_blank">UiPasta</a></div>
  <!-- UiPasta Credit End -->
  
   
 </footer>
</div>
 <!-- Footer End -->

 
</div>
</div>

   
</div>
</div>
</div>

<!-- Blog Post (Right Sidebar) End -->
    
    
     
     <!-- Endpage Box (Popup When Scroll Down) Start 
     <div id="scroll-down-popup" class="endpage-box">
       <h4>Read Also</h4>
       <a href="#">How to make your company website based on bootstrap framework...</a>
      </div>
      <!-- Endpage Box (Popup When Scroll Down) End -->
      
    
    
    
    <!-- Back to Top Start -->
    <a href="#" class="scroll-to-top"><i class="fa fa-long-arrow-up"></i></a>
    <!-- Back to Top End -->
    
    
    <!-- All Javascript Plugins  -->
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/plugin.js"></script>
    
    <!-- Main Javascript File  -->
    <script type="text/javascript" src="js/scripts.js"></script>
    
    <!-- Syntax Highlighter Javascript File  -->
    <script type="text/javascript" src="js/syntax/shCore.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushCss.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushJScript.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPerl.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPhp.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPlain.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushPython.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushRuby.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushSql.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushVb.js"></script>
    <script type="text/javascript" src="js/syntax/shBrushXml.js"></script>
    
	<!-- Syntax Highlighter Call Function -->
	<script type="text/javascript">
		SyntaxHighlighter.config.clipboardSwf = 'js/syntax/clipboard.swf';
		SyntaxHighlighter.all();
	</script>

    
   </body>
 </html>
